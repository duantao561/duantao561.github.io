<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>人工智能(10)--信用卡欺诈识别</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD10/</url>
    <content><![CDATA[<p>设计算法根据信用卡的消费记录识别欺诈</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>信用卡公司需要能够识别虚假的信用卡交易，以避免用户被骗。本题就是利用欧洲某段时间的信用卡交易记录，来判断某条交易是否属于信用卡欺诈。</p>
<h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>数据集为2013年9月里某两天欧元区的信用卡交易记录。在这两天中共有284807笔交易，其中的492笔是欺诈。把欺诈交易的类(class) 认为是1，非欺诈交易的类认为是0. 那么这个二元问题中，class为1的样本概率只有0.172%。可见在这个二元问题中，两个类所占的比重相差特别大。也就是说我们的数据集是特别不平衡的。因此同学们在本题中要思考如何处理这种失衡的数据。失衡数据很可能导致train出来的模型是无效模型，具体会在下面“小提示”部分详细说明。</p>
<p>数据集里面有从PCA转换得到的28个features。在下方我放了一点关于PCA转换的阅读材料，感兴趣的同学可以阅读了解一下。<strong>但是不了解不影响答题，不建议过多把时间花在上面。</strong>之所以进行了PCA转换是因为不能把原始的消费者信用卡记录暴露给公众，这样触犯了用户的隐私。所以做PCA转换处理。可以简单理解为加密。</p>
<p>Features V1, V2, …, V28都是经过PCA转换后获得的features。没有被PCA转换的，保留了原始数据的是”Time”和”Amount”。”Time”记录了每笔交易和第一笔交易之间的时间间隔，以秒为单位。”Amount”是交易数额。”Class”就是这笔交易的最终分类。如果为1说明这是一笔欺诈交易，为0说明这不是一笔欺诈交易。</p>
<ul>
<li>PCA Transformation</li>
<li><a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Principal_component_analysis</a></li>
<li><a href="https://www.cs.princeton.edu/picasso/mats/PCA-Tutorial-Intuition_jp.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/picasso/mats/PCA-Tutorial-Intuition_jp.pdf</a></li>
</ul>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li><p>本题数据是非常不平衡的，只有0.172%的交易为欺诈交易。所以如果模型什么也不做，直接把所有的交易预测为非欺诈，也会有超过90%的准确率。因此准确率在本题中不是衡量模型好坏的有效指标。而且对于银行来说，检验到欺诈交易远比检验到非欺诈交易重要。因此本题用来衡量模型好坏的指标是F1值。F1值有既考虑precision，又考虑recall的优点。</p>
</li>
<li><p>可以尝试使用Resampling，包括oversampling, undersampling来处理unbalance数据。参考资料:</p>
</li>
<li><p><a href="http://contrib.scikit-learn.org/imbalanced-learn/stable/over_sampling.html" target="_blank" rel="noopener">http://contrib.scikit-learn.org/imbalanced-learn/stable/over_sampling.html</a></p>
</li>
<li><p><a href="https://www.marcoaltini.com/blog/dealing-with-imbalanced-data-undersampling-oversampling-and-proper-cross-validation" target="_blank" rel="noopener">https://www.marcoaltini.com/blog/dealing-with-imbalanced-data-undersampling-oversampling-and-proper-cross-validation</a></p>
</li>
<li><p>Classification问题，可以从Naive Bayes, Logistic Regression, Decision Tree入手</p>
</li>
<li><p>尝试用Cross Validation提高模型效果</p>
</li>
</ul>
<h2 id="先修知识"><a href="#先修知识" class="headerlink" title="先修知识"></a>先修知识</h2><ul>
<li>F1 score: <a href="https://en.wikipedia.org/wiki/F1_score" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/F1_score</a></li>
<li>TN / True Negative: case was negative and predicted negative</li>
<li>TP / True Positive: case was positive and predicted positive</li>
<li>FN / False Negative: case was positive but predicted negative</li>
<li>FP / False Positive: case was negative but predicted positive</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>成功找到欺诈交易，尽量不遗漏。</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>一般classification问题可能考虑准确率就够了。但是本题由于超过90%的分类都为非欺诈，即使直接“预测”成非欺诈也会有90%以上的正确率。因此precision在本题并不是最重要的指标。应当注意到，银行更关注的是欺诈交易有没有被都筛选出来，也是recall这个指标所表示的含义。因此本题为了兼顾precision和recall，选择<strong>F1 score</strong>作为模型好坏的衡量指标，公式为<br>$$F1=\frac{2}{(\frac{1}{P}+\frac{1}{R})}$$<br>$$P=\frac{TP}{TP+FP}$$<br>$$R=\frac{TP}{TP+FN}$$</p>
<h2 id="测评配置环境"><a href="#测评配置环境" class="headerlink" title="测评配置环境"></a>测评配置环境</h2><p>python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U scikit-learn</span><br><span class="line">pip install -U numpy</span><br><span class="line">pip install -U pandas</span><br></pre></td></tr></table></figure>
<p>从”数据”那一栏获得代码测试文件。命令行里跑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 scorer.py --predicted_file &lt;predicted_file_path&gt; --true_file &lt;true_file_path&gt;</span><br></pre></td></tr></table></figure>
<p>可通过这个script运用Cross Validation验证你的模型在training data上的performance</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据集共包含284807条数据。每条记录的第一列Id用作索引。你可能注意到索引并不是连续的。这是因为原始数据并没有区分训练集和测试集。在出题时，这个数据集被认为按照0.8, 0.2的比例分成了训练集和测试集。第二列为“时间”，是这条记录和第一笔记录之间的时间间隔。“时间”后面跟着V1-V28共28个由PCA转换得到features。PCA features后面是amount，代表本次交易的金额。最后的class是要预测的值。如果为0代表这条交易不是欺诈，为1则为欺诈。</p>
<p>如前所述，数据集已经按照0.8, 0.2的比例分成了训练集和测试集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creditcard_test.csv   </span><br><span class="line">creditcard_train.csv    百度网盘小号</span><br><span class="line">scorer.py  </span><br><span class="line">sample_submission.csv</span><br></pre></td></tr></table></figure>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><ul>
<li>提交的csv文件应采用以下格式：一共包含两列，第一列Id代表测试集中对应的数列Id，第二列Class则代表预测出的该笔交易的分类。具体可看提供的sample_submission.csv</li>
</ul>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(11)--共享单车</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD11/</url>
    <content><![CDATA[<p>预测每时段共享单车使用数量概率</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>共享单车是当下十分流行的租借交通，使用共享单车，人们可以从一个地方租借一辆单车，并行驶到想去的地方，之后把车停在那里即可。</p>
<p>共享单车的使用量变化是一个很有吸引力的问题。共享单车的使用量可用于研究城市交通的移动性，也可帮助企业进行收支分析，例如对于一个区域，究竟投放多少辆，不同时间又需要多少人维护，这些问题对于企业发展都非常重要。而共享单车的使用量并非一成不变的，尤其针对不同的时段、日期，使用量存在较大的差异。</p>
<p>这道题，给出了某个地区在一段时间内的共享单车使用量，预测该时段内之后的使用量。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>先检查数据是否存在<a href="https://baike.baidu.com/item/缺失值" target="_blank" rel="noopener">缺失值</a>。</li>
<li>数据的列并是很多，但是如何提取出有效的feature是至关重要的。</li>
<li>多画图，多分析，多筛选。</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>特征选择和特征组合</li>
<li>相关系数和相关矩阵分析</li>
<li>随机森林、逻辑回归、L1、L2正则化</li>
<li><a href="https://www.baidu.com/link?url=nDZgfl9XdmcrqsF28kTCQr97n_690DfvtcqvZW5aleB9JpuUiB-j5FOmMDMLjCbT&amp;wd=&amp;eqid=acc5f7bd00378fae000000035b1d0d2f" target="_blank" rel="noopener">seaborn</a></li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><a href="https://baike.baidu.com/item/特征选择/4950639" target="_blank" rel="noopener">特征选择</a>：特征选择( Feature Selection )也称特征子集选择( Feature Subset Selection , FSS )，或属性选择( Attribute Selection )。是指从已有的M个特征(Feature)中选择N个特征使得系统的特定指标最优化，是从原始特征中选择出一些最有效特征以降低数据集维度的过程,是提高学习算法性能的一个重要手段,也是<a href="https://baike.baidu.com/item/模式识别" target="_blank" rel="noopener">模式识别</a>中关键的数据预处理步骤。对于一个学习算法来说,好的学习样本是训练模型的关键。</li>
<li><a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">L1、L2正则化</a>：L1正则化和L2正则化可以看做是损失函数的惩罚项。所谓『惩罚』是指对损失函数中的某些参数做一些限制。对于线性回归模型，使用L1正则化的模型建叫做Lasso回归，使用L2正则化的模型叫做Ridge回归（岭回归）。</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>使用Root Mean Squared Logarithmic Error (RMSLE)进行预测，其公式如下：</p>
<p>$$\sqrt{\frac{1}{k}\sum_{i=1}^{k}(\lg{(true_i + 1)} - \lg{(pred_i + 1)}) ^ 2}$$</p>
<ul>
<li>k是总样本</li>
<li>true是真实值</li>
<li>pred是预测值</li>
<li>lg(x)是以2为底的对数函数</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据包括了train、test两张表，数据字段含义如下：</p>
<ul>
<li>datetime 日期时间</li>
<li>season 1、2、3、4分别对应春夏秋冬</li>
<li>holiday 今天是否是节假日</li>
<li>workingday 今天是否是工作日</li>
<li>weather 1 晴天、多云;2 雾天;3 小雨、小雪;4 大雨、冰雹、暴雪</li>
<li>temp 摄氏温度</li>
<li>atemp 体感摄氏温度</li>
<li>humidity 湿度</li>
<li>windspeed 风速</li>
<li>casual 非登记用户用车</li>
<li>registered 登记用户用车</li>
<li>count 总用车量</li>
</ul>
<p>train表是日期从每月1-15日的数据，test表是每月16-19日的数据，也是将要进行预测的时间段。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>请按test集顺序输出对应的结果，注意，如果不按顺序可能影响分数哦。具体如下，可详见sample_submission.csv。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datetime,count</span><br><span class="line">2011-01-16 00:00:00,10</span><br><span class="line">2011-01-16 01:00:00,10</span><br><span class="line">2011-01-16 02:00:00,10</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(12)--蛋白质二级结构预测</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD12/</url>
    <content><![CDATA[<p>给定一串氨基酸序列，预测其折叠后的二级结构</p>
<a id="more"></a>
<h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>蛋白质折叠问题是生物信息学中最重要的板块之一,而其中最受人关注的毫无疑问是:如何根据给定的氨基酸序列预测其对应的蛋白质结构。</p>
<p>一个蛋白质分子的生物学性质与其三维结构存在着密不可分的关系,而蛋白质的天然三维结构正是由氨基酸单体的链式结构折叠而来。然而事实证明,从氨基酸序列直接预测蛋白质空间结构往往效果不佳。</p>
<p>因此,在这道题中，请尝试使用课上所学过的模型，以及主流的深度深度学习框架，将其运用于预测蛋白质的二级结构中,从而在一级链式<br>结构与三级空间结构中架起一座桥梁。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>氨基酸序列是一串由多个氨基酸单体排列组成的链式结构。一共有20种常见的氨基酸单体，其单个字母缩写表示为：[A R N D C Q E G H I L K M F P S T W Y V]。而每一条氨基酸序列在折叠成蛋白质的过程中，会逐渐显现出其二级结构，在这里我们使用较为简单的3分类模型：[α-螺旋，β-折叠以及无规卷曲（random coil）]，分别用[H，E，C]来表示。</p>
<p>当一条氨基酸序列经过折叠后，序列中不同的区域会显现出不同的二级结构，因此，序列中的每个氨基酸单体都可以找到其对应的二级结构类型，而相邻的氨基酸单体往往会属于同一个二级结构，因为不论是α-螺旋还是β-折叠，都是多个氨基酸单体折叠在一起后才产生的结构。</p>
<p>在本题中，请你使用给定的氨基酸序列及其对应二级结构作为训练数据，将其预处理成你所需要的数据格式后，训练出一个分类器，用于蛋白质二级结构的预测。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>因为本次月考是人工智能训练营的最后一次月考，也是最后一次大作业，所以本题中给出的数据会更加接近现实，题目也变得更有挑战性。</p>
</li>
<li><p>源文件将是一个只经过些许预处理的txt文件，因此你需要根据你的网络结构，来自行预处理数据。例如：如何提取X_train, 和Y_train？是将整个训练集保存为一个文件，还是多个文件？是否自行encoding，还是使用开源框架的内置函数？所有的操作都将由你的模型来决定。</p>
</li>
<li><p>鼓励使用tensorflow或是pytorch等开源框架，因为其提供了自动微分功能，极大地降低了训练的难度，同时他们提供的tutorials是非常、非常有帮助的。</p>
</li>
<li><p>建议从最简单的neural network训练起，再尝试CNN，RNN等复杂模型。有时候，简单的或许是最好的 ；）</p>
</li>
</ol>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>你提交的<code>submission.csv</code>文件，将使用[准确率(accuracy)]作为最后评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$ Accuracy=\frac{Number of Correct Predictions}{Number of Total Predictions} $$</p>
<ul>
<li><p>在本题中，我们将二级结构分为3类（α-螺旋，β-折叠以及无规卷曲（random coil））。因此每一个氨基酸的二级结构预测值都应当属于这3类之一。</p>
</li>
<li><p>在统计准确率时，这里我们将比较每一条氨基酸序列中，每一个氨基酸单体所对应的二级结构预测值和真实值。即，在一条长度为k的氨基酸序列中，它包含k个氨基酸单体，其number of prediction = k。 因此，Number of Correct Predictions为你预测正确的氨基酸单体的总个数，而Number of Total Predictions为所有的氨基酸序列的长度总和，accuracy_score即为此二者之比。</p>
</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>在这里我们给出了两个txt文件，分别是训练集：ss100_train.txt和测试集：ss100_test.txt。训练集（training set）包含10000条氨基酸序列以及其对应的二级结构，而测试集（test set）中只包含了400条氨基酸序列，用于最终预测并上传答案。每一条氨基酸序列的长度在[50,100]之间。</p>
<p>ss100_train.txt中数据以如下形式储存：氨基酸序列数据以4行为一周期，其中第1、3行是标签，用来告诉你该氨基酸序列的ID，以及下一行是氨基酸序列还是其对应的二级结构。4行中的第2行是氨基酸单体序列，第4行是其对应的二级结构。</p>
<p>举例来说：</p>
<blockquote>
<p>1A1Y:I:sequence<br>KTEWPELVGKSVEEAKKVILQDKPEAQIIVLPVGTIVTMEYRIDRVRLFVDKLDNIAEVPRVG<br>1A1Y:I:secstr<br>CCECHHHCCCEHHHHHHHHHHHCCCCEEEEEECCCEEECCCCCCEEEEEECCCCEECCCCEEC</p>
</blockquote>
<p>第一行表示这个氨基酸序列代号为：1A02:J，sequence表示它的下一行是amino acid sequence，即氨基酸序列；第二行是该氨基酸序列的字母缩写表达；第三行里的secstr为Secondary Structure的缩写，表示下一行是该氨基酸序列所对应的二级结构；第四行就是其二级结构的字母缩写表达。</p>
<p>第二行的氨基酸单体字母缩一共有20种可能，为：[A R N D C Q E G H I L K M F P S T W Y V]。而第四行中的二级结构一共有3类——[H，E，C]，其分别代表[α-螺旋，β-折叠以及无规卷曲（random coil）]。</p>
<p>请注意，第二行与第四行的长度一定是完全相同的，因为每一个氨基酸单体都会在二级结构中找到其对应的分类。因此，简而言之，你所需要做的事就是找到一个分类器，帮助预测氨基酸序列中的每一个单体，所对应的二级结构类型。</p>
<p>需要注意的是，因为这里提供的是txt文件，因此你需要手动将其转换成适合神经网络读入的格式。另外，因为训练集中包含了10000条训练数据，所以有需要的话可以将其划分为训练集（training set）以及验证集（dev set），来进行交叉验证（k-fold Cross Validation）等。一些别的建议请参考题目描述中的<em>注意事项</em>板块。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>当你训练完一个有效的分类器后（可以是神经网络或其他任何你熟悉的分类器），请将自行预处理过的测试集数据作为分类器的输入，并将输出存储在提交的csv文件中。</p>
<p>提交的csv文件应采用以下格式：一共只包含1列—class，代表所预测的所有氨基酸序列的每个单体的二级结构。由于氨基酸序列的长度各不相同（[50,100])，因此请按ss100_test.txt中的顺序，将所有的输出reshape成1列，并存在class里。具体来说，就是将每一个氨基酸序列的预测结果先转化为（-1，1）的格式，再将不同的氨基酸序列的预测结果竖直拼接在一起，最终成为一列。最终拼接后的列向量的长度应为(32508,1）。<br>可参看提供的sample_submission.csv</p>
<p>！！！请注意：为了便于批改，在输出中，请用”0“代表”H“，“1”代表“E”，”2“代表”C“。 因此，提交的文件中除了第一行为”class“外，其余内容应该都为”0“，”1“或”2“</p>
<p>！！！再次强调：请按ss100_test.txt中氨基酸序列的顺序输出预测，不然即使总长度对了，中间对应的氨基酸不对应也是无效的。</p>
<p>若对上述表达仍有困惑，此段代码仅供参考。<br>y_pred.reshape(-1, 1)<br>data = pd.DataFrame({‘class’: y_pred})<br>data.to_csv(‘submit.csv’, index=False)</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(13)--句子情感分类</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD13/</url>
    <content><![CDATA[<p>判断社交网络中的句子的情感倾向</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>UMICH SI650 情感分类是一个经典的NLP数据集。数据集中的句子全部来源于社交网络和博客，是带有情感色彩的主观性文本。本题的目的在于区分一句话的情感是“积极的”还是“消极的”。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题的关键在于拿到文本后，如何构造词向量</li>
<li>词向量构造完毕后，根据词向量字典，将句子送入神经网络进行预测</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>分词</li>
<li>word2vec</li>
<li>LSTM</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>你提交的<code>submission.csv</code>文件，将使用<a href="https://www.zhihu.com/question/19645541" target="_blank" rel="noopener">准确率(accuracy)</a>作为最后评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$ Accuracy=\frac{TP+TN}{TP+FN+FP+TN} $$</p>
<p>其中</p>
<p>TP(True Positive)是将正类预测为正类的结果数目</p>
<p>FP(False Positive)是将负类预测为正类的结果数目</p>
<p>TN(True Negative)是将负类预测为负类的结果数目</p>
<p>FN(False Negative)是将正类预测为负类的结果数目</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>训练集train.csv包含5,668个记录，每个记录有两列，含义如下：</p>
<ul>
<li>sentence：句子的具体内容</li>
<li>label: 句子的情感分类，1为积极情感，0为消极情感，即我们要预测的值</li>
</ul>
<p>测试集test.csv包含1,418个记录，只包含sentence字段，label为需要预测的值，且预测值只能为0或1</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>请按test集给出的顺序进行预测，具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentence label</span><br><span class="line">Ok brokeback mountain is such a horrible movie. 0</span><br><span class="line">Brokeback Mountain was so awesome. 1</span><br><span class="line">friday hung out with kelsie and we went and sa... 0</span><br><span class="line">I am going to start reading the Harry Potter s... 1</span><br><span class="line">Is it just me, or does Harry Potter suck?... 0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(1)--汽车投保风险</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD1_%E6%B1%BD%E8%BD%A6%E6%8A%95%E4%BF%9D%E9%A3%8E%E9%99%A9/</url>
    <content><![CDATA[<p>给定汽车的各项性能指标，设计算法对汽车的投保风险进行打分</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某保险公司销售一种汽车保险，需要对汽车状态进行评估。现在你需要设计一个算法模型，可以根据汽车的各项指标对汽车的投保风险进行打分。投保风险是从0到70的正整数，数值越大代表风险越高。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题是一个典型的回归问题</li>
<li>先从<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 车辆的特征中有数值型和类别性，数值型的特征注意进行范围标准化，类别型的特征转化为one-hot encoding的形式</span><br><span class="line">* 模型可以使用传统的回归模型，如[SVR(支持向量回归)](http://www.jianshu.com/p/c867e9234035)，[CART(分类与回归树)](http://blog.csdn.net/baimafujinji/article/details/53269040)等。但强烈建议使用集成学习的算法将多个简单模型集成为一个复杂模型，如[Random Forest(随机森林)](https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97?fromtitle=Random+forest&amp;fromid=18081353)，[Adaboost](https://baike.baidu.com/item/adaboost)等，在使用[集成学习(Ensemble Learning)](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0)的方法时，要注意引入正则化项，防止模型过拟合</span><br><span class="line">* 最后使用训练好的模型预测```test.csv```中每辆车的风险分数</span><br><span class="line"></span><br><span class="line">## 先修技能</span><br><span class="line"></span><br><span class="line">* 懂得基本的机器学习回归模型的原理和使用，如[SVR(支持向量回归)](http://www.jianshu.com/p/c867e9234035)，[CART(分类与回归树)](http://blog.csdn.net/baimafujinji/article/details/53269040)等。</span><br><span class="line">* 懂得集成学习的相关算法，如[Random Forest(随机森林)](https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97?fromtitle=Random+forest&amp;fromid=18081353)，[Adaboost](https://baike.baidu.com/item/adaboost)等。</span><br><span class="line"></span><br><span class="line">## 术语解释</span><br><span class="line">* [SVR(支持向量回归)](http://www.jianshu.com/p/c867e9234035) : 是一种基于SVM(支持向量机)的回归方法。支持向量回归在做拟合时，采用了支持向量的思想，和拉格朗日乘子式的方式，来对数据进行回归分析</span><br><span class="line">* [CART(分类与回归树)](http://blog.csdn.net/baimafujinji/article/details/53269040) : 属于一种特殊的决策树，其假设决策树是二叉树，内部结点特征的取值为“是”和“否”，这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布，常用来做分类和回归分析。</span><br><span class="line">* [集成学习(Ensemble Learning)](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0) : 是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合从而获得比单个学习器更好的学习效果的一种机器学习方法</span><br><span class="line">* [Random Forest(随机森林)](https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97?fromtitle=Random+forest&amp;fromid=18081353) : 指的是利用多棵树对样本进行训练并预测的一种分类器。在机器学习领域，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定</span><br><span class="line">* [Adaboost](https://baike.baidu.com/item/adaboost) : 是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">## 目标</span><br><span class="line"></span><br><span class="line">给定汽车的各项性能指标，设计算法对汽车的投保风险进行打分</span><br><span class="line"></span><br><span class="line">## 评价</span><br><span class="line"></span><br><span class="line">对于提交的文件，我们将使用RMSE \(Root Mean Square Error\)作为评价指标，公式如下：</span><br><span class="line"></span><br><span class="line">$$RMSE=\sqrt&#123;\frac&#123;\sum_&#123;i=1&#125;^N(y_i-\hat&#123;y_i&#125;)^2&#125;&#123;N&#125;&#125;$$</span><br><span class="line"></span><br><span class="line">其中$N$代表测试数据集中汽车的数量，$y_&#123;i&#125;$代表其真实的风险值，$\hat&#123;y_i&#125;$代表你预测的风险值。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">数据文件`train.csv`和`test.csv`包含多辆汽车的信息。每辆汽车有如下信息：</span><br><span class="line"></span><br><span class="line">1. Id: 每个汽车的唯一id</span><br><span class="line">2. Score: 汽车的风险数值\(整数，仅train.csv中包含此信息\)</span><br><span class="line">3. Col\_1 ~ Col\_32: 每个汽车的32个特征，其中有数值型，有类别型\(用字母表示）</span><br><span class="line"></span><br><span class="line">训练数据集\(train.csv\)包含34列，分别对应上述信息。测试数据集\(test.csv\)包含33列，不包含Score信息。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">您需要提交一个`submission.csv`文件，文件应采用以下格式：对于测试集中的每辆汽车，输出一行，其中包含汽车的Id和您预测的风险值。 您的提交文件将如下所示：</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Id,Score<br>1,5<br>2,6<br>…<br>etc.<br><code>`</code></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(2)--泰坦尼克号</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD2/</url>
    <content><![CDATA[<p>给定泰坦尼克号船上乘客的信息，设计一个算法模型来判断一名乘客在沉船灾难中能否最终存活下来</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>泰坦尼克号</strong>(RMS Titanic)是英国白星航运公司下辖的一艘奥林匹克邮轮，在其处女航行中，因与一座冰山相撞而至沉船。在这次事故中，有约2/3的人丧生。现在给定泰坦尼克号船上的乘客信息，你需要学习一个模型来判断一名乘客在沉船灾难中能否最终存活下来。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题是一个典型的二分类问题</li>
<li>先从<code>train.csv</code>中提取每个乘客的多项特征（feature）和存活信息(label)，使用feature和label进行模型训练</li>
<li>乘客的特征选取和处理比较重要。类别的特征，如Embarked、Pclass等，可以转换成one-hot encoding的表示形式。数值型的特征，如Age、Parch等可以进行范围标准化。一些很难处理和使用的特征，如Name等，可以考虑直接忽略</li>
<li>模型可以使用传统的分类模型，如SVM，Decision Tree等。在训练过程中，要适当引入正则化项，防止模型过拟合，而致其泛化能力变差</li>
<li>最后使用训练好的模型预测<code>test.csv</code>中的乘客最终能否存活</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>懂得基本的机器学习分类模型的原理和使用，如SVM，Decision Tree等。</li>
<li>懂得集成学习的相关算法，如Random Forest，Adaboost等。</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><a href="https://baike.baidu.com/item/svm/4385807?fr=aladdin" target="_blank" rel="noopener">SVM(支持向量机)</a> : 是一种判别方法。在机器学习领域，支持向量机是一个监督学习模型，通常用来进行模式识别和分类</li>
<li><a href="https://baike.baidu.com/item/决策树?fromtitle=Decision+Tree&amp;fromid=11319683" target="_blank" rel="noopener">Decision Tree(决策树)</a> : 是一种十分常用的机器学习方法。在机器学习领域，决策树是一个监督学习模型，他代表的是对象属性与对象值之间的一种映射关系，通常用来进行分类以及回归分析</li>
<li><a href="https://baike.baidu.com/item/集成学习" target="_blank" rel="noopener">集成学习(Ensemble Learning)</a> : 是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合从而获得比单个学习器更好的学习效果的一种机器学习方法</li>
<li><a href="https://baike.baidu.com/item/随机森林?fromtitle=Random+forest&amp;fromid=18081353" target="_blank" rel="noopener">Random Forest(随机森林)</a> : 指的是利用多棵树对样本进行训练并预测的一种分类器。在机器学习领域，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定</li>
<li><a href="https://baike.baidu.com/item/adaboost" target="_blank" rel="noopener">Adaboost</a> : 是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</li>
</ul>
<p>##评价<br>本题对提交的测试结果使用<a href="https://www.zhihu.com/question/19645541" target="_blank" rel="noopener">准确率(accuracy)</a>作为最后评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$Accuracy=\frac{TP+TN}{TP+FN+FP+TN}$$</p>
<p>其中</p>
<p>TP(True Positive)是将正类预测为正类的结果数目</p>
<p>FP(False Positive)是将负类预测为正类的结果数目</p>
<p>TN(True Negative)是将负类预测为负类的结果数目</p>
<p>FN(False Negative)是将正类预测为负类的结果数目</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据文件train.csv和test.csv包含多名乘客的信息。每名乘客有如下信息：</p>
<ol>
<li>PassengerId : 乘客的唯一ID</li>
<li>Survived : 乘客最终是否存活(0 = No, 1 = Yes, 仅train.csv中包含此信息)</li>
<li>Pclass : 乘客的船票的等级(1 = 1st, 2 = 2nd, 3 = 3rd)</li>
<li>Name : 乘客名字</li>
<li>Sex : 乘客性别(male, female)</li>
<li>Age : 乘客年龄(Year)</li>
<li>Sibsp ：船上兄弟姐妹/配偶的人数</li>
<li>Parch : 船上父母/儿女的人数</li>
<li>Ticket : 船票号码</li>
<li>Fare : 船票价格</li>
<li>Cabin : 船舱号</li>
<li>Embarked : 出发港口(C = Cherbourg, Q = Queenstown, S = Southampton)</li>
</ol>
<p>训练数据集<code>train.csv</code>包含12列，分别对应上述信息。测试数据集<code>test.csv</code>包含11列，不包含Survival信息。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个<code>submission.csv</code>文件，文件应采用<code>gender_submission.csv</code>的格式，具体如下：对于测试集中的每位乘客，输出一行，其中包含PassengerId和预测这个乘客是否会存活的结果。 例如，如果您预测第一个乘客存活，第二个乘客不会存活，第三个乘客不会存活，那么您的提交文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PassengerId,Survived</span><br><span class="line">1,1</span><br><span class="line">2,0</span><br><span class="line">3,0 </span><br><span class="line">(415 more lines)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(3)--Criteo 展示广告</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD3/</url>
    <content><![CDATA[<p>预测用户是否会点击广告</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Criteo是一家第三方展示广告公司，与世界上超过4000家电子商务公司有合作关系。<br>说到广告，关注的最多的就是点击率了。我们经常能听说某某科学家通过建立更好的点击率预测模型，为公司带来上亿的增量收入。<br>本题我们使用Criteo所共享的一周展示广告数据，数据中提炼了13个连续特征、26个离散特征和用户是否点击了该页面广告的标签。请你训练出合适的模型，预测用户在不同的特征下是否会点击广告。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li><p>关于<a href="http://blog.csdn.net/supinyu/article/details/52248934" target="_blank" rel="noopener">点击率</a>的一些基本知识：<br>无论是人工运营还是机器决策，我们都希望对某条广告或内容可能的点击率有一个预判，以便判断哪些条目应该被放在更重要的位置上。<br>广告点击率(CTR)的计算公式为 CTR=click次数/show次数</p>
</li>
<li><p>数据预处理：本题可以考虑对连续特征做等频的离散化处理，对类目特征做one hot encoding</p>
</li>
<li><p>模型：可以考虑主流的“logistic regression + L1正则”，也可以尝试<a href="http://blog.csdn.net/bitcarmanlee/article/details/52143909" target="_blank" rel="noopener">Factorization Machine</a>模型(FM主要是为了解决数据稀疏的情况下，特征怎样组合的问题)</p>
</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li><p>会使用<a href="http://www.jianshu.com/p/005a4e6ac775" target="_blank" rel="noopener">GBDT</a>(梯度提升决策树)</p>
</li>
<li><p>了解<a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="noopener">Logistic Regression</a>, <a href="https://www.zhihu.com/question/27126057/answer/92250611?utm_source=wechat_session&amp;utm_medium=social#showWechatShareTip" target="_blank" rel="noopener">Logarithmic Loss</a>(log对数损失函数)的使用场景</p>
</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><p><a href="http://www.jianshu.com/p/005a4e6ac775" target="_blank" rel="noopener">GBDT（梯度提升决策树）</a>: 又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力较强的算法。GBDT中的树是回归树（不是分类树），GBDT用来做回归预测，调整后也可以用于分类。GBDT的思想使其具有天然优势可以发现多种有区分性的特征以及特征组合。</p>
</li>
<li><p><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="noopener">Logic Regression（逻辑回归）</a>: logistic regression的起源主要分为几个阶段，从开始想到logistic这个词，到发现logistic function，再推导出logit function，最后才命名logistic regression。logistic起源于对人口数量增长情况的研究，逻辑回归作为Regression Analysis的一个分支，它实际上还受到很多Regression Analysis相关技术的启发。逻辑回归是为了解决分类问题，根据一些已知的训练集训练好模型，再对新的数据进行预测属于哪个类。</p>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>使用<a href="https://www.zhihu.com/question/27126057/answer/92250611?utm_source=wechat_session&amp;utm_medium=social#showWechatShareTip" target="_blank" rel="noopener">Logarithmic Loss</a> 作为最后评判标准,公式如下：</p>
<p>$$logloss=-\frac{1}{n}\sum_{i=1}^N\sum_{j=1}^My_{i,j}\log(p_{i,j})$$</p>
<p>其中$N$代表测试数据集中访问记录的数量，其中$M$代表测试数据集中预测的分类数量（该题中为2，代表预测点击与未点击），$y_{i}$代表其真实的点击情况（0为未点击，1为点击），$\log(p_{i,j})$代表你预测的点击概率。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>数据文件<code>train.csv</code>提供了1599条的用户访问网页和点击广告记录的对应特征，l1～l13为计数特征，c1～c26为类别特征。Label表示用户是否点击广告，0为未点击，1为点击。如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Id,Label,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16,C17,C18,C19,C20,C21,C22,C23,C24,C25,C26</span><br><span class="line">10000743,1,1.0,0,1.0,,227.0,1.0,173.0,18.0,50.0,1.0,7.0,1.0,,75ac2fe6,1cfdf714,713fbe7c,aa65a61e,25c83c98,3bf701e7,7195046d,0b153874,a73ee510,9e5006cd,4d8549da,a48afad2,51b97b8f,b28479f6,d345b1a0,3fa658c5,3486227d,e88ffc9d,c393dc22,b1252a9d,57c90cd9,,bcdee96c,4d19a3eb,cb079c2d,456c12a0</span><br><span class="line">10000159,1,4.0,1,1.0,2.0,27.0,2.0,4.0,2.0,2.0,1.0,1.0,,2.0,05db9164,6c9c9cf3,2730ec9c,5400db8b,25c83c98,7e0ccccf,8a6600b0,813607cc,a73ee510,e4b08fda,4ab39743,be45b877,ab8a1a53,07d13a8f,06969a20,9bc7fff5,07c540c4,92555263,,,242bb710,,3a171ecb,72c78f11,,</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure></p>
<p>数据文件<code>test.csv</code>与<code>train.csv</code>类似，提供了<code>train.csv</code>之后一段时间的用户访问网页和点击广告记录对应特征。<br>如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Id,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16,C17,C18,C19,C20,C21,C22,C23,C24,C25,C26</span><br><span class="line">10000743,1.0,0,1.0,,227.0,1.0,173.0,18.0,50.0,1.0,7.0,1.0,,75ac2fe6,1cfdf714,713fbe7c,aa65a61e,25c83c98,3bf701e7,7195046d,0b153874,a73ee510,9e5006cd,4d8549da,a48afad2,51b97b8f,b28479f6,d345b1a0,3fa658c5,3486227d,e88ffc9d,c393dc22,b1252a9d,57c90cd9,,bcdee96c,4d19a3eb,cb079c2d,456c12a0</span><br><span class="line">10000159,4.0,1,1.0,2.0,27.0,2.0,4.0,2.0,2.0,1.0,1.0,,2.0,05db9164,6c9c9cf3,2730ec9c,5400db8b,25c83c98,7e0ccccf,8a6600b0,813607cc,a73ee510,e4b08fda,4ab39743,be45b877,ab8a1a53,07d13a8f,06969a20,9bc7fff5,07c540c4,92555263,,,242bb710,,3a171ecb,72c78f11,,</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure></p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>根据测试集给出的用户访问记录，预测出用户点击某个广告的概率，第一列为记录Id，第二列为点击概率。输出文件名为<code>submission.csv</code>,输出格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Id,Predicted</span><br><span class="line">60000000,0.384</span><br><span class="line">63895816,0.5919</span><br><span class="line">759281658,0.1934</span><br><span class="line">895936184,0.9572</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(4)--猫和狗</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD4/</url>
    <content><![CDATA[<p>给出一张猫或狗的图片，识别出这是猫还是狗？</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一张猫或狗的图片，识别出这是猫还是狗。</p>
<p>这种识别具有很重要的意义，比如：</p>
<p>Web服务为了进行保护，会防止一些计算机进行恶意访问或信息爬取，进而设立一些验证问题，这些验证问题对于人来说很容易做，但是对于计算机这很困难。这样的方法称为<a href="https://baike.baidu.com/item/Captcha" target="_blank" rel="noopener">CAPTCHA</a>（完全自动公开的图灵测试）或HIP（人类交互证明）。 HIP有很多用处，例如减少垃圾邮件，防止暴力破解密码等。</p>
<p>比较有名的Asirra（用于限制访问的动物图像识别）就是一个HIP，它会让用户识别图片信息，比如识别出图片中是猫还是狗。对于人来说这很容易，但是对于计算机很困难。以下是Asirra的一个例子：</p>
<p>寻找流浪宠物为其提供住所的网站——Petfinder.com，向微软研究院提供了超过三百万张猫和狗的图像，这些图片由美国各地成千上万的动物收容所手动分类。</p>
<p>对于要入侵的计算机，随机猜测一般是最简单的攻击方法。图片识别并不容易，因为图片之间不同的的背景，角度，姿势，亮度等都存在着巨大的差异，很难识别。</p>
<p>不过随着机器学习——尤其是神经网络的发展，这项工作精度可以达到60%以上。而60％分类器就已经能将12幅图像的猜测概率从1/4096提高到1/459。</p>
<p>这道题目会给大家上万张的图片作为训练集，你能在猫狗之间分辨出它们的差异吗？</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题是一个图像识别中的二分类问题</li>
<li>建议先把不同尺寸的图片想办法转换成同样格式的输入，例如把图片变成一样的分辨率，可以采用一些图片尺寸放缩的方法，例如：<a href="https://baike.baidu.com/item/双线性插值/11055945?fr=aladdin" target="_blank" rel="noopener">双线性插值</a>或<a href="http://blog.chinaunix.net/uid-7525568-id-3452691.html" target="_blank" rel="noopener">临近取样插值</a>等</li>
<li>统一输入后可以采用卷积神经网络，至于<a href="https://baike.baidu.com/item/卷积神经网络/17541100?fr=aladdin" target="_blank" rel="noopener">卷积神经网络</a>的细节架构可以参考一些经典的模型，比如<a href="https://www.cnblogs.com/52machinelearning/p/5821591.html" target="_blank" rel="noopener">LeNet或VGGNet</a>等</li>
<li>最后使用该CNN（卷积神经网络）进行预测</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>掌握初步的图像处理能力，如转化<a href="https://baike.baidu.com/item/灰度图像/1962298?fr=aladdin" target="_blank" rel="noopener">灰度图像</a>，彩色图像的表示。</li>
<li>掌握<a href="https://baike.baidu.com/item/卷积神经网络/17541100?fr=aladdin" target="_blank" rel="noopener">卷积神经网络</a>及相关的技巧，如<a href="http://ufldl.stanford.edu/wiki/index.php/Softmax回归" target="_blank" rel="noopener">SoftMax</a>、<a href="https://www.cnblogs.com/neopenx/p/4453161.html" target="_blank" rel="noopener">ReLu</a>等， 或者<a href="https://baike.baidu.com/item/svm/4385807?fr=aladdin" target="_blank" rel="noopener">SVM</a>等较强的<a href="https://baike.baidu.com/item/分类器" target="_blank" rel="noopener">分类器</a>。</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><p><a href="https://baike.baidu.com/item/卷积神经网络/17541100?fr=aladdin" target="_blank" rel="noopener">卷积神经网络</a>：在机器学习中，卷积神经网络是一种深度前馈人工神经网络，已成功地应用于图像识别。卷积神经网络是一种前馈神经网络，人工神经元可以响应周围单元，可以大型图像处理。卷积神经网络包括卷积层和池化层。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/灰度图像/1962298?fr=aladdin" target="_blank" rel="noopener">灰度图像</a>：灰度数字图像是每个像素只有一个采样颜色的图像。这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑白两种颜色，灰度图像在黑色与白色之间还有许多级的颜色深度。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/双线性插值/11055945?fr=aladdin" target="_blank" rel="noopener">双线性插值</a>，又称为双线性内插。在数学上，双线性插值是有两个变量的插值函数的<a href="https://baike.baidu.com/item/线性插值" target="_blank" rel="noopener">线性插值</a>扩展，其核心思想是在两个方向分别进行一次线性插值。双线性插值作为数值分析中的一种插值算法，广泛应用在信号处理，数字图像和视频处理等方面。</p>
</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>给出一张猫或狗的图片，识别出这是猫还是狗？</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>本题对于提交文件，将使用 <a href="https://www.zhihu.com/question/19645541" target="_blank" rel="noopener">准确率(accuracy)</a> 作为评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$ Accuracy=\frac{TP+TN}{TP+FN+FP+TN} $$</p>
<p>TP(True Positive)是将正类预测为正类的结果数目</p>
<p>FP(False Positive)是将负类预测为正类的结果数目</p>
<p>TN(True Negative)是将负类预测为负类的结果数目</p>
<p>FN(False Negative)是将正类预测为负类的结果数目</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p><code>train.zip</code>包含了20000个猫和狗的jpg图片这些图片大小不尽相同，在这些图片上进行训练。(1=狗，0=猫)的标签其中id即为’.jpg’前面的文件编号</p>
<p><code>test.zip</code>是用来预测的测试集数据。 建议不要手动修改test的预测Label。</p>
<p>以上两个文件见百度网盘小号</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个文件，文件应采用<code>sampleSubmission.csv</code>的格式，具体如下：对于测试集中的每张图片，输出一行，其中包含图片id和对应预测的结果（<strong>1=狗，0=猫</strong>）。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id,label</span><br><span class="line">1,1</span><br><span class="line">2,1</span><br><span class="line">3,0 </span><br><span class="line"></span><br><span class="line">(etc...)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(5)--Otto Group 商品识别</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD5/</url>
    <content><![CDATA[<p>给定Otto Group一些商品的各类特征，需要学习一个模型来判断一个商品所属的类别</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Otto Group是世界上最大的电子商务公司之一，在全世界范围内，它每天会卖出数百万件商品。每件商品所属的类别分别是Class_1～ Class_9。对于这家公司的来说，货物供给和需求分析是非常重要的信息。现给定一些商品的多个特征，你需要设计一个算法模型来判断一个商品所属的类别。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题是一个典型的多分类问题</li>
<li>先从<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 商品的每个特征都是数值型，在使用SVM等分类器时注意将数据范围标准化</span><br><span class="line">* 商品的特征较多，在使用Decision Tree等树形分类器时，注意引入正则化项，防止模型过拟合</span><br><span class="line">* 题目要求预测商品属于Class\_1～ Class\_9的概率，使用深度学习模型，如MLP时，建议在神经网络的最后一层使用softmax函数，使得神经网络的输出与题目要求完全相符</span><br><span class="line">* 最后使用训练好的模型预测```test.csv```中每件商品的类别</span><br><span class="line"></span><br><span class="line">## 先修技能</span><br><span class="line"></span><br><span class="line">* 懂得基本的机器学习分类模型的原理和使用，如[SVM(支持向量机)](https://baike.baidu.com/item/svm/4385807?fr=aladdin)，[Decision Tree(决策树)](https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E6%A0%91?fromtitle=Decision+Tree&amp;fromid=11319683)等。</span><br><span class="line">* 懂得[集成学习(Ensemble Learning)](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0) 的相关算法，如[Random Forest(随机森林)](https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97?fromtitle=Random+forest&amp;fromid=18081353)，[Adaboost](https://baike.baidu.com/item/adaboost)等。</span><br><span class="line">* 懂得神经网络的使用，如[MLP(多层感知机)](https://baike.baidu.com/item/MLP/17194455) 等。</span><br><span class="line"></span><br><span class="line">## 术语解释</span><br><span class="line">* [SVM(支持向量机)](https://baike.baidu.com/item/svm/4385807?fr=aladdin) : 是一种判别方法。在机器学习领域，支持向量机是一个监督学习模型，通常用来进行模式识别和分类</span><br><span class="line">* [Decision Tree(决策树)](https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E6%A0%91?fromtitle=Decision+Tree&amp;fromid=11319683) : 是一种十分常用的机器学习方法。在机器学习领域，决策树是一个监督学习模型，他代表的是对象属性与对象值之间的一种映射关系，通常用来进行分类以及回归分析</span><br><span class="line">* [集成学习(Ensemble Learning)](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0) : 是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合从而获得比单个学习器更好的学习效果的一种机器学习方法</span><br><span class="line">* [Random Forest(随机森林)](https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97?fromtitle=Random+forest&amp;fromid=18081353) : 指的是利用多棵树对样本进行训练并预测的一种分类器。在机器学习领域，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定</span><br><span class="line">* [Adaboost](https://baike.baidu.com/item/adaboost) : 是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</span><br><span class="line">* [MLP(多层感知机)](https://baike.baidu.com/item/MLP/17194455) : 是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量。MLP是感知器的推广，克服了感知器不能对线性不可分数据进行识别的弱点。</span><br><span class="line"></span><br><span class="line">## 评价</span><br><span class="line"></span><br><span class="line">本题我们对于提交的`submission.csv`文件将使用 multi-class logarithmic loss 作为最后评判标准，公式如下：</span><br><span class="line"></span><br><span class="line">$$logloss = -\frac&#123;1&#125;&#123;N&#125;\sum_&#123;i=1&#125;^N\sum_&#123;j=1&#125;^My_&#123;ij&#125;log(p_&#123;ij&#125;)$$</span><br><span class="line"></span><br><span class="line">其中$N$代表测试数据集中的商品数量，$log$使用自然对数，$y_&#123;ij&#125;$表示商品$i$是否属于$j$，如果是则$y_&#123;ij&#125;=1$，否则为$0$。$p_&#123;ij&#125;$代表你预测商品$i$属于$class_j$的概率。</span><br><span class="line"></span><br><span class="line">### 输入格式</span><br><span class="line"></span><br><span class="line">数据文件`train.csv`和`test.csv`包含多个商品的信息。每个商品有如下信息：</span><br><span class="line"></span><br><span class="line">1. id: 每个商品的唯一id</span><br><span class="line">2. feat\_1 ~ feat\_93: 每个商品的93个特征</span><br><span class="line">3. target: 商品的真正类别\(仅train.csv中包含此信息\)</span><br><span class="line"></span><br><span class="line">训练数据集`train.csv`包含95列，分别对应上述信息。测试数据集`test.csv`包含94列，不包含target信息。</span><br><span class="line"></span><br><span class="line">### 输出格式</span><br><span class="line"></span><br><span class="line">您需要提交一个文件，文件应采用`sampleSubmission.csv`的格式，具体如下：对于测试集中的每个商品，输出一行，其中包含商品的id和您预测的其分别属于Class\_1 ~ Class\_9的概率（要求概率和为1）。 您的提交文件将如下所示：</span><br></pre></td></tr></table></figure></li>
</ul>
<p>id,Class_1,Class_2,Class_3,Class_4,Class_5,Class_6,Class_7,Class_8,Class_9<br>1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0<br>2,0.0,0.2,0.3,0.3,0.0,0.0,0.1,0.1,0.0<br>…<br>etc.<br><code>`</code></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(6)--识别脸部特征</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD6/</url>
    <content><![CDATA[<p>你能教会计算机识别五大洲人种的眼耳口鼻吗？</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>人脸关键点检测是一个非常困难的问题,不同图片的灯光、角度、人脸尺寸都会导致脸部特征的巨大不同。经过几十年的艰苦研究,克服重重困难,计算机视觉相关研究者在该领域得到了巨大的成就,但仍然还有很多问题值得探索。</p>
<p>在本题中，你的任务是：从人物头像的灰度照片(96x96像素)中找出代表面部器官位置的关键点坐标,关键点包括眼睛中心,嘴巴中心等共15位置。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li><p><a href="http://www.voidcn.com/article/p-xmmvlhfa-gb.html" target="_blank" rel="noopener">人脸关键点检测</a>：一张人脸图片输入后，需要先找到人脸的位置（人脸检测），然后在这个基础上定位人脸关键点的位置（如眼睛中心或嘴角等）。</p>
</li>
<li><p>人脸关键点检测的方法：</p>
</li>
</ul>
<p>1、投影：五官灰度值较周围皮肤灰度值低。</p>
<p>2、基于先验规则：先验知识指的是人脸比如眼睑、虹膜等一些已知的灰度、形状信息。</p>
<p>3、基于几何形状：比如可变形模板，能够较好检测眼睛嘴唇特征形状。但是由于边缘不精确难以精确定位特征点，依赖初始参数大，容易陷入局部最小，计算时间长。另外还有主动形状模型（ASM），主动表观模型（AAM）。</p>
<p>4、基于统计的方法：该方法的思想是将特征部位看做一类模式，然后使用大量的特征部位样本和非特征部位样本进行训练。然后构造分类器，该类方法主要有PCA（主成分分析）、SVM、ANN（神经网络）、AdaBoost、模板匹配。</p>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>掌握<a href="https://baike.baidu.com/item/卷积神经网络/17541100?fr=aladdin" target="_blank" rel="noopener">卷积神经网络</a>及相关的技巧，如<a href="http://ufldl.stanford.edu/wiki/index.php/Softmax回归" target="_blank" rel="noopener">SoftMax</a>、<a href="https://www.cnblogs.com/neopenx/p/4453161.html" target="_blank" rel="noopener">ReLu</a>等， 或者<a href="https://baike.baidu.com/item/svm/4385807?fr=aladdin" target="_blank" rel="noopener">SVM</a>等较强的<a href="https://baike.baidu.com/item/分类器" target="_blank" rel="noopener">分类器</a>。</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><p><a href="https://baike.baidu.com/item/卷积神经网络/17541100?fr=aladdin" target="_blank" rel="noopener">卷积神经网络</a>：在机器学习中，卷积神经网络是一种深度前馈人工神经网络，已成功地应用于图像识别。卷积神经网络是一种前馈神经网络，人工神经元可以响应周围单元，可以大型图像处理。卷积神经网络包括卷积层和池化层。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/svm/4385807?fr=aladdin" target="_blank" rel="noopener">SVM(支持向量机)</a> : 是一种判别方法。在机器学习领域，支持向量机是一个监督学习模型，通常用来进行模式识别和分类</p>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>本题对提交文件，将使用RMSE (Root Mean Square Error)作为评价指标,公式如下：<br>$$ RMSE = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}<em>i)^2} $$<br>其中$N$代表测试数据集中特征的数量，$y</em>{i}$代表其真实的坐标值，$\hat{y_i}$代表你预测的坐标值。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>文件 在百度网盘小号（facial_data）<br><code>train.csv</code>提供了大约5000个人物头像的灰度图片,像素96x96,灰度0-255,图片数据的矩阵被整理成一维向量,用空格分割,并附有每个头像15个关键点的位置坐标（x轴y轴）,关键点坐标用逗号分隔。数据格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left_eye_center_x,left_eye_center_y,right_eye_center_x,right_eye_center_y,left_eye_inner_corner_x,left_eye_inner_corner_y,left_eye_outer_corner_x,left_eye_outer_corner_y,right_eye_inner_corner_x,right_eye_inner_corner_y,right_eye_outer_corner_x,right_eye_outer_corner_y,left_eyebrow_inner_end_x,left_eyebrow_inner_end_y,left_eyebrow_outer_end_x,left_eyebrow_outer_end_y,right_eyebrow_inner_end_x,right_eyebrow_inner_end_y,right_eyebrow_outer_end_x,right_eyebrow_outer_end_y,nose_tip_x,nose_tip_y,mouth_left_corner_x,mouth_left_corner_y,mouth_right_corner_x,mouth_right_corner_y,mouth_center_top_lip_x,mouth_center_top_lip_y,mouth_center_bottom_lip_x,mouth_center_bottom_lip_y,Image</span><br><span class="line">66.0335639098,39.0022736842,30.2270075188,36.4216781955,59.582075188,39.6474225564,73.1303458647,39.9699969925,36.3565714286,37.3894015038,23.4528721805,37.3894015038,56.9532631579,29.0336481203,80.2271278195,32.2281383459,40.2276090226,29.0023218045,16.3563789474,29.6474706767,44.4205714286,57.0668030075,61.1953082707,79.9701654135,28.6144962406,77.3889924812,43.3126015038,72.9354586466,43.1307067669,84.4857744361, 96x96 more pixels</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure></p>
<p><code>test.csv</code>格式与<code>train.csv</code>接近,没有提供关键点的位置坐标。每行数据由图片数据组成，图片数据的矩阵被整理成一维向量，用空格分割。数据格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image</span><br><span class="line">238 236 237 238 240...</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure></p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个文件，文件应采用sampleSubmission.csv的格式，具体如下：根据测试集给出的头像图片数据,预测出每个人物头像的关键点的位置坐标。第一列为特征行号,第二列为特征值。输出格式如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RowId,Location</span><br><span class="line">1,?</span><br><span class="line">2,?</span><br><span class="line">3,?</span><br><span class="line">4,?</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(7)--垃圾短信分类</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD7/</url>
    <content><![CDATA[<p>给一条英文短信，试判断该短信是否为垃圾短信。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>本题提供一个数据集, 它包括了5574条英文短信，每条短信内容由几个长短不一的句子组成。每条短信都标注好了是否为垃圾短信，通过该训练集训练出一个分类器，预测短信内容是否为垃圾短信。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li><p>数据处理：可以使用分词工具，然后将句子转换成词向量，建立词表。简单的，可以通过统计词汇表中词汇出现的次数构建向量。</p>
</li>
<li><p>但是上述这种简单地构建向量的方式，会导致每个词的重要过于均衡，无法体现词向量中词汇的重要性，导致分类结果不理想。改进中，可以采用<a href="https://deeplearning4j.org/cn/bagofwords-tf-idf" target="_blank" rel="noopener">TF-IDF</a>方式来构建词向量。</p>
</li>
<li><p>此时建立的向量通常是高度稀疏的，我们需要对建立的向量进行降维。方法可以采用主成分分析法等。</p>
</li>
<li><p>这之后，可以使用条件概率来进行分类，实现贝叶斯分类器</p>
</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li><p>会使用<a href="https://www.jiqizhixin.com/articles/2017-06-24-5" target="_blank" rel="noopener">svm</a>或者<a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="noopener">bayes</a>等分类器</p>
</li>
<li><p>会数据降维方法，如<a href="http://blog.csdn.net/zhongkelee/article/details/44064401" target="_blank" rel="noopener">主成分分析法</a>（pca）</p>
</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><p><a href="https://www.jiqizhixin.com/articles/2017-06-24-5" target="_blank" rel="noopener">SVM分类</a>：支持向量机，一般简称SVM。通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p>
</li>
<li><p><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="noopener">贝叶斯（bayes）分类</a>：贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。</p>
</li>
<li><p><a href="http://blog.csdn.net/zhongkelee/article/details/44064401" target="_blank" rel="noopener">主成分分析</a>：主成分分析也称主分量分析，旨在利用降维的思想，把多指标转化为少数几个综合指标。<br>在统计学中，主成分分析（PCA）是一种简化数据集的技术。它是一个线性变换。这个变换把数据变换到一个新的坐标系统中，使得任何数据投影的第一大方差在第一个坐标(称为第一主成分)上，第二大方差在第二个坐标(第二主成分)上，依次类推。主成分分析经常用减少数据集的维数，同时保持数据集的对方差贡献最大的特征。这是通过保留低阶主成分，忽略高阶主成分做到的。这样低阶成分往往能够保留住数据的最重要方面。但是，这也不是一定的，要视具体应用而定。</p>
</li>
<li><p>原始数据集可参见链接：<a href="http://www.dt.fee.unicamp.br/~tiago/smsspamcollection/" target="_blank" rel="noopener">http://www.dt.fee.unicamp.br/~tiago/smsspamcollection/</a></p>
</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>给一条英文短信，试判断该短信是否为垃圾短信。</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>你提交的<code>submission.csv</code>文件，将使用<a href="https://www.zhihu.com/question/19645541" target="_blank" rel="noopener">准确率(accuracy)</a>作为最后评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$ Accuracy=\frac{TP+TN}{TP+FN+FP+TN} $$</p>
<p>其中</p>
<p>TP(True Positive)是将正类预测为正类的结果数目</p>
<p>FP(False Positive)是将负类预测为正类的结果数目</p>
<p>TN(True Negative)是将负类预测为负类的结果数目</p>
<p>FN(False Negative)是将正类预测为负类的结果数目</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据文件<code>train.csv</code>包含5574英文短信。<br>每条短信占一行，每行由两列构成。第一列是短信相应的标签<code>label</code>，如果是<code>ham</code>表示为非垃圾短信，如果是<code>spam</code>表示为垃圾短信。第二列是短信的具体内容，由长短不一的几句英文组成。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Label,Text</span><br><span class="line">ham,Aight should I just plan to come up later tonight?</span><br><span class="line">ham,Was the farm open?</span><br><span class="line">ham,&quot;I sent my scores to sophas and i had to do secondary application for a few schools. I think if you are thinking of applying, do a research on cost also. Contact joke ogunrinde, her school is one me the less expensive ones&quot;</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>
<p>数据文件<code>test.csv</code>每行由两列构成。第一列是短信相应的Id<code>SmsId</code>,第二列是短信的具体内容，由长短不一的几句英文组成。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SmsId,Text</span><br><span class="line">4456,Aight should I just plan to come up later tonight?</span><br><span class="line">690,Was the farm open?</span><br><span class="line">944,&quot;I sent my scores to sophas and i had to do secondary application for a few schools. I think if you are thinking of applying, do a research on cost also. Contact joke ogunrinde, her school is one me the less expensive ones&quot;</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个文件，文件应采用<code>sampleSubmission.csv</code>的格式，具体如下：对于测试集中的每条短信，输出一行，其中包含SmsId和您预测其是否为垃圾短信的结果，不是为ham、是为spam。 例如，如果您预测第一条短信是垃圾短信，第二条不是，那么您的提交文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SmsId,Label</span><br><span class="line">1,spam</span><br><span class="line">2,ham</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(8)--电影评论识别</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD8/</url>
    <content><![CDATA[<p>通过电影评论的文字信息中识别出评论者的态度</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对电影的评论文字的处理是自然语言处理中情感分析方向的一个很好的例子。人们的语言经常具有不确定性，有的甚至包括了讽刺、反语等等。如何识别出评论者的态度是一大难点。</p>
<p>在这道题中，给出电影评论，要求识别出这条评论是积极的还是消极的。</p>
<p>对于文字处理的方法一般为：第一步从自然语言中提取出特征，第二步对特征进行适当的分类器训练。（在分类器的选择中建议采用<a href="https://baike.baidu.com/item/神经网络/174248" target="_blank" rel="noopener">神经网络</a>等比较强的分类器。）</p>
<p>第一步特征提取可以尝试采用Google的<a href="https://www.cnblogs.com/iloveai/p/word2vec.html" target="_blank" rel="noopener">Word2Vec</a>方法，Word2Vec试图理解单词之间的含义和语义关系。它的原理类似于递归神经网络，但计算效率更高。此外也可以使用<a href="https://baike.baidu.com/item/tf-idf/8816134?fr=aladdin" target="_blank" rel="noopener">TF-IDF</a>、<a href="http://blog.csdn.net/u010213393/article/details/40987945" target="_blank" rel="noopener">词袋法</a>等等。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li>本题是一道<a href="https://baike.baidu.com/item/自然语言处理" target="_blank" rel="noopener">自然语言处理</a>当中的<a href="https://baike.baidu.com/item/情感分析器/8025608" target="_blank" rel="noopener">情感分析</a>。</li>
<li>可以先从句子当中提取出特征，方法如<a href="https://www.cnblogs.com/iloveai/p/word2vec.html" target="_blank" rel="noopener">Word2Vec</a>，<a href="https://baike.baidu.com/item/tf-idf/8816134?fr=aladdin" target="_blank" rel="noopener">TF-IDF</a>，<a href="http://blog.csdn.net/u010213393/article/details/40987945" target="_blank" rel="noopener">词袋法</a>等等。</li>
<li>提取出特征后，可以采用<a href="https://baike.baidu.com/item/朴素贝叶斯" target="_blank" rel="noopener">朴素贝叶斯</a>，朴素贝叶斯在文本处理当中有比较好的表现效果。也可以采用<a href="https://baike.baidu.com/item/svm" target="_blank" rel="noopener">SVM</a>、<a href="https://baike.baidu.com/item/递归神经网络" target="_blank" rel="noopener">递归神经网络</a>等较强的分类器。</li>
<li>通过该分类器，给出一个概率值，这个值不需要再进一步处理为0-1二值，因为这里采用AUC进行评价。</li>
</ul>
<h2 id="先修技能"><a href="#先修技能" class="headerlink" title="先修技能"></a>先修技能</h2><ul>
<li>掌握<a href="http://blog.csdn.net/u010213393/article/details/40987945" target="_blank" rel="noopener">词袋法</a>、<a href="https://baike.baidu.com/item/tf-idf" target="_blank" rel="noopener">TF-IDF</a>或Word2Vec等文本特征提取技术。</li>
<li>掌握循<a href="https://baike.baidu.com/item/递归神经网络" target="_blank" rel="noopener">递归神经网络</a>、<a href="https://baike.baidu.com/item/朴素贝叶斯" target="_blank" rel="noopener">朴素贝叶斯</a>或其他分类器。</li>
<li>理解<a href="https://baike.baidu.com/item/AUC/2498115" target="_blank" rel="noopener">AUC</a>评价指标。</li>
<li>会<a href="https://baike.baidu.com/item/svm" target="_blank" rel="noopener">svm</a>或者<a href="https://baike.baidu.com/item/RNN" target="_blank" rel="noopener">rnn</a>等分类器的使用。</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><p><a href="https://baike.baidu.com/item/递归神经网络" target="_blank" rel="noopener">循环神经网络</a>：<strong>循环神经网络</strong>（<strong>RNN</strong>）是两种<a href="https://baike.baidu.com/item/人工神经网络" target="_blank" rel="noopener">人工神经网络</a>的总称。一种是<strong>时间递归神经网络</strong>（recurrent neural network），另一种是<strong>结构递归神经网络</strong>（recursive neural network）。时间递归神经网络的神经元间连接构成<a href="https://baike.baidu.com/item/有向图" target="_blank" rel="noopener">有向图</a>，而结构递归神经网络利用相似的神经网络结构递归构造更为复杂的深度网络。两者训练的算法不同，但属于同一算法变体。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/朴素贝叶斯" target="_blank" rel="noopener">朴素贝叶斯</a>：朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBM）。和决策树模型相比，朴素贝叶斯分类器(Naive Bayes Classifier,或 NBC)发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/tf-idf" target="_blank" rel="noopener">TF-IDF</a>：TF-IDF是一种<a href="https://baike.baidu.com/item/统计方法" target="_blank" rel="noopener">统计方法</a>，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在<a href="https://baike.baidu.com/item/语料库" target="_blank" rel="noopener">语料库</a>中出现的频率成反比下降。TF-IDF加权的各种形式常被<a href="https://baike.baidu.com/item/搜索引擎" target="_blank" rel="noopener">搜索引擎</a>应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜寻结果中出现的顺序。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/AUC/2498115" target="_blank" rel="noopener">AUC</a>：AUC（Area Under Curve）被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。</p>
</li>
<li><p><a href="https://www.cnblogs.com/iloveai/p/word2vec.html" target="_blank" rel="noopener">Word2Vec</a>：word2vec可以在百万数量级的词典和上亿的数据集上进行高效地训练，该工具得到的训练结果——词向量（word embedding），可以很好地度量词与词之间的相似性。随着深度学习（Deep Learning）在自然语言处理中应用的普及，很多人误以为word2vec是一种深度学习算法。其实word2vec算法的背后是一个浅层神经网络。另外需要强调的一点是，word2vec是一个计算word vector的开源工具。当我们在说word2vec算法或模型的时候，其实指的是其背后用于计算word vector的CBoW模型和Skip-gram模型。很多人以为word2vec指的是一个算法或模型，这也是一种谬误。</p>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>使用 AUC 作为最后评判标准。</p>
<p>下面简单介绍AUC，介绍AUC之前先介绍ROC：</p>
<p><img src="/images/jiuzhang2.jpg" alt></p>
<p>正如我们在这个ROC曲线的示例图中看到的那样，ROC曲线的横坐标为false positive rate（FPR），纵坐标为true positive rate（TPR）。下图中详细说明了FPR和TPR是如何定义的。</p>
<p><img src="/images/jiuzhang1.jpg" alt></p>
<p>接下来我们考虑ROC曲线图中的四个点和一条线。第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。类似的，第四个点（1,1），分类器实际上预测所有的样本都为正样本。经过以上的分析，我们可以断言，ROC曲线越接近左上角，该分类器的性能越好。</p>
<p>AUC（Area Under Curve）被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。</p>
<p>既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。这时使用AUC评价指标就会更加准确。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><ul>
<li><code>labeledTrainData.tsv</code>是有Label的训练集，包含20000行评论数据，包括评论id、评论文本、情感（0代表消极，1代表积极）。</li>
<li><code>testData.tsv</code>是一个无Label的测试集，包含5000行评论数据，包括评论id、评论文本，没有对应情感。</li>
<li><code>unlabeledTrainData.tsv</code>是额外的50000行无Label数据，包括评论id和评论文本。<strong>可用来进行文本特征提取或半监督学习。</strong></li>
<li><code>sampleSubmission.csv</code>是一个提交格式的样例。</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个文件，文件应采用sampleSubmission.csv的格式，具体如下：对于测试集中的每条评论，输出一行，其中包含评论id和对应预测的结果（<strong>注意，可以提交[0, 1]以内的任意数值，表示预测为正例的score，最终会采用AUC进行评价，</strong><a href="https://baike.baidu.com/item/AUC/19282953?fr=aladdin" target="_blank" rel="noopener"><em>AUC的科普链接</em></a>）。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id,sentiment</span><br><span class="line">3862_4,0</span><br><span class="line">674_10,1</span><br><span class="line">8828_10,0</span><br><span class="line"></span><br><span class="line">(4997 more lines)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能(9)--数字图像识别</title>
    <url>/2019/08/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD9/</url>
    <content><![CDATA[<p>给一张图片，图片里面写了一个数字可能是0-9，然后需要设计算法判断出这个数字是0-9中哪一个数字。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>MNIST是计算机视觉领域的“hello world”数据集。 自1999年发布以来，这种手写图像的经典数据集已经成为基准分类算法的基础。 随着新的机器学习技术的出现，MNIST仍然是研究人员和学习者的可靠资源。</p>
<p>这个题目，您的目标是正确识别数以万计的手写图像数据集中的数字。<br>每一张图片，图片里面写了一个数字可能是0-9，然后需要设计算法判断出这个数字是0-9中哪一个数字。 我们鼓励您尝试不同的算法，以便第一手掌握哪些方法或者技术可行。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ul>
<li><p>若对神经网络比较熟悉，可以直接建立一个单层神经网络，输入是784个像素，经过一个全链接层，然后激励函数和<a href="https://www.zhihu.com/question/23765351" target="_blank" rel="noopener">softmax</a>，输出为一个<a href="http://www.jianshu.com/p/a47a1c1fa3f1" target="_blank" rel="noopener">one-hot编码</a>的预测结果，共10个类别，分别代表0-9，选择对应概率最大的作为预测数字。</p>
</li>
<li><p>以上是没有数据预处理的方法。但如果我们对数据做一个小处理：比如提取每行像素值最大的元素和每列最大的元素，则输入数据从784维降到了28+28=56维。这个时候再经过一个单层神经网络，也可以获得一个很好的预测结果，而且由于数据降维，我们的训练时间会大大减少。</p>
</li>
</ul>
<h2 id="先修技能："><a href="#先修技能：" class="headerlink" title="先修技能："></a>先修技能：</h2><ul>
<li><p>具有<a href="https://www.zhihu.com/question/22553761" target="_blank" rel="noopener">Neural Network</a>的基本知识：</p>
</li>
<li><p>会<a href="https://www.zhihu.com/question/21094489" target="_blank" rel="noopener">SVM</a>或者<a href="http://www.csuldw.com/2015/05/21/2015-05-21-KNN/" target="_blank" rel="noopener">KNN</a>等分类器的使用</p>
</li>
</ul>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><ul>
<li><a href="https://www.zhihu.com/question/22553761" target="_blank" rel="noopener">Neural Network</a>：在机器学习和认知科学领域，人工神经网络，是一种模仿生物神经网络的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统。现代神经网络是一种非线性统计性数据建模工具。典型的神经网络具有以下三个部分：</li>
</ul>
<p>1、结构：结构指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重和神经元的激励值。</p>
<p>2、激励函数：大部分神经网络模型具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激励函数依赖于网络中的权重（即该网络的参数）。</p>
<p>3、学习规则：学习规则指定了网络中的权重如何随着时间推进而调整，这一般被看做是一种长时间尺度的动力学规则。一般情况下，学习规则依赖于神经元的激励值，它也可能依赖于监督者提供的目标值和当前权重的值。例如，用于手写识别的一个神经网络，有一组输入神经元，输入神经元会被输入图像的数据所激发。在激励值被加权并通过一个函数（由网络的设计者确定）后，这些神经元的激励值被传递到其他神经元。这个过程不断重复，直到输出神经元被激发。最后，输出神经元的激励值决定了识别出来的是哪个字母。</p>
<ul>
<li><p><a href="https://www.zhihu.com/question/21094489" target="_blank" rel="noopener">SVM</a>：在机器学习中，支持向量机（SVM）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个。SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为非概率二元线性分类器。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。</p>
</li>
<li><p><a href="http://www.csuldw.com/2015/05/21/2015-05-21-KNN/" target="_blank" rel="noopener">KNN</a>：在模式识别领域中，最近邻居法（KNN算法，又译K-近邻算法）是一种用于分类和回归的非参数统计方法。在这两种情况下，输入包含特征空间中的k个最接近的训练样本。在k-NN分类中，输出是一个分类族群。一个对象的分类是由其邻居的“多数表决”确定的。k个最近邻居（k为正整数，通常较小）中最常见的分类决定了赋予该对象的类别。若k = 1，则该对象的类别直接由最近的一个节点赋予。在k-NN回归中，输出是该对象的属性值。该值是其k个最近邻居的值的平均值。</p>
</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本次比赛的目标是拍摄一个手写的单个数字的图像，并确定这个数字是什么。<br>对于测试集中的每个ImageId，请预测是什么数字。</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>你提交的<code>submission.csv</code>文件，将使用<a href="https://www.zhihu.com/question/19645541" target="_blank" rel="noopener">准确率(accuracy)</a>作为最后评判标准。</p>
<p>准确率(accuracy)是用来衡量算法预测结果的准确程度，具体指测试集中算法预测正确的数量占总数的比例。</p>
<p>$$ Accuracy=\frac{TP+TN}{TP+FN+FP+TN} $$</p>
<p>其中</p>
<p>TP，True Positive，将正类预测为正类的数目</p>
<p>FP，False Positive，将负类预测为正类数</p>
<p>TN，True Negative，将负类预测为负类数</p>
<p>FN，False Negative，将正类预测为负类数</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>（train.csv和test.csv这两个文件在 百度网盘小号）</p>
<p>数据文件train.csv和test.csv包含从0到9的手绘数字的灰度图像。</p>
<p>每幅图像的高度为28像素，宽度为28像素，总共为784像素。每个像素都有一个与之相关的像素值，表示该像素的亮度或暗度，数字越高意味着越暗。这个像素值是一个0到255之间的整数。</p>
<p>训练数据集（train.csv）有785列。第一列称为“标签”，是用户绘制的数字。其余列包含关联图像的像素值。</p>
<p>训练集中的每个像素列都有一个名称，如pixelx，其中x是0到783之间的整数。为了在图像上定位这个像素，假设我们已经将x分解为x = i * 28 + j，其中i和j是0到27之间的整数。然后，pixelx位于28 x 28矩阵的第i行和第j列（索引为零）。</p>
<p>例如，像素31表示位于从左边开始的第四列的像素，以及从顶端开始的第二行，如下面的ASCII图所示。</p>
<p>在视觉上，如果我们省略“像素”前缀，则像素组成像这样的图像：</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>您需要提交一个文件，文件应采用sampleSubmission.csv的格式，具体如下：第一行：ImageId，Label。从第二行开始，对于测试集test.csv中的28000个图像，每个图像对应输出一行，其中包含ImageId和您预测的数字。 例如，如果您预测第一个图像是3，第二个图像是7，第三个图像是8，那么您的提交文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ImageId,Label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1,3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2,7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3,8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(27997 more lines)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众平台图文分析数据接口</title>
    <url>/2019/08/23/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E6%96%87%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="微信公众平台图文分析数据接口"><a href="#微信公众平台图文分析数据接口" class="headerlink" title="微信公众平台图文分析数据接口"></a>微信公众平台图文分析数据接口</h1><h2 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1. 接口定义"></a>1. 接口定义</h2><h3 id="1-1-获取图文群发每日数据（getarticlesummary）"><a href="#1-1-获取图文群发每日数据（getarticlesummary）" class="headerlink" title="1.1 获取图文群发每日数据（getarticlesummary）"></a>1.1 获取图文群发每日数据（getarticlesummary）</h3><ul>
<li><strong>接口地址：</strong><br><code>https://api.weixin.qq.com/datacube/getarticlesummary?access_token=ACCESS_TOKEN</code></li>
</ul>
<a id="more"></a>
<h4 id="1-1-1-请求参数"><a href="#1-1-1-请求参数" class="headerlink" title="1.1.1 请求参数"></a>1.1.1 请求参数</h4><ul>
<li>请求示例：（最大时间跨：<strong>1</strong> ）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;begin_date&quot;: &quot;2019-12-13&quot;, </span><br><span class="line">    &quot;end_date&quot;: &quot;2019-12-13&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-返回结果"><a href="#1-1-2-返回结果" class="headerlink" title="1.1.2 返回结果"></a>1.1.2 返回结果</h4><table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">出现要求</th>
<th style="text-align:left">描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">list&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">List</td>
<td style="text-align:left">R&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ref_date</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">数据的日期，需在begin_date和end_date之间</td>
</tr>
<tr>
<td style="text-align:left">&emsp;user_source</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">在获取图文阅读分时数据时才有该字段，代表用户从哪里进入来阅读该图文。0:会话;1.好友;2.朋友圈;3.腾讯微博;4.历史消息页;5.其他;6.看一看;7.搜一搜</td>
</tr>
<tr>
<td style="text-align:left">&emsp;msgid</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">请注意：这里的msgid实际上是由msgid（图文消息id，这也就是群发接口调用后返回的msg_data_id）和index（消息次序索引）组成， 例如12003_3， 其中12003是msgid，即一次群发的消息的id； 3为index，假设该次群发的图文消息共5个文章（因为可能为多图文），3表示5个中的第3个</td>
</tr>
<tr>
<td style="text-align:left">&emsp;title</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文消息的标题</td>
</tr>
<tr>
<td style="text-align:left">&emsp;int_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页（点击群发图文卡片进入的页面）的阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;int_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ori_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页（点击图文页“阅读原文”进入的页面）的阅读人数，无原文页时此处数据为0</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ori_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;share_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;share_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;add_to_fav_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;add_to_fav_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的次数</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">            &quot;user_source&quot;: 0,</span><br><span class="line">            &quot;msgid&quot;: &quot;2247492953_1&quot;,</span><br><span class="line">            &quot;title&quot;: &quot;宝宝树孕育、育学园及亲宝宝用户粘性行业领先&quot;,</span><br><span class="line">            &quot;int_page_read_user&quot;: 3,</span><br><span class="line">            &quot;int_page_read_count&quot;: 4,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">            &quot;user_source&quot;: 0,</span><br><span class="line">            &quot;msgid&quot;: &quot;2247492956_1&quot;,</span><br><span class="line">            &quot;title&quot;: &quot;智能穿戴市场，小天才电话手表用户规模稳居榜首&quot;,</span><br><span class="line">            &quot;int_page_read_user&quot;: 2,</span><br><span class="line">            &quot;int_page_read_count&quot;: 2,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">            &quot;user_source&quot;: 0,</span><br><span class="line">            &quot;msgid&quot;: &quot;2247492959_1&quot;,</span><br><span class="line">            &quot;title&quot;: &quot;高德地图高居地图导航市场首位&quot;,</span><br><span class="line">            &quot;int_page_read_user&quot;: 3,</span><br><span class="line">            &quot;int_page_read_count&quot;: 3,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-获取图文群发总数据（getarticletotal）"><a href="#1-2-获取图文群发总数据（getarticletotal）" class="headerlink" title="1.2 获取图文群发总数据（getarticletotal）"></a>1.2 获取图文群发总数据（getarticletotal）</h3><ul>
<li><strong>接口地址：</strong><br><code>https://api.weixin.qq.com/datacube/getarticletotal?access_token=ACCESS_TOKEN</code></li>
</ul>
<h4 id="1-1-1-请求参数-1"><a href="#1-1-1-请求参数-1" class="headerlink" title="1.1.1 请求参数"></a>1.1.1 请求参数</h4><p>请求示例：（最大时间跨：<strong>1</strong> ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;begin_date&quot;: &quot;2019-12-13&quot;, </span><br><span class="line">    &quot;end_date&quot;: &quot;2019-12-13&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-返回结果-1"><a href="#1-1-2-返回结果-1" class="headerlink" title="1.1.2 返回结果"></a>1.1.2 返回结果</h4><table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">出现要求</th>
<th style="text-align:left">描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">list&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">List</td>
<td style="text-align:left">R&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ref_date</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">数据的日期，需在begin_date和end_date之间</td>
</tr>
<tr>
<td style="text-align:left">&emsp;user_source</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">在获取图文阅读分时数据时才有该字段，代表用户从哪里进入来阅读该图文。0:会话;1.好友;2.朋友圈;3.腾讯微博;4.历史消息页;5.其他;6.看一看;7.搜一搜</td>
</tr>
<tr>
<td style="text-align:left">&emsp;msgid</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">请注意：这里的msgid实际上是由msgid（图文消息id，这也就是群发接口调用后返回的msg_data_id）和index（消息次序索引）组成， 例如12003_3， 其中12003是msgid，即一次群发的消息的id； 3为index，假设该次群发的图文消息共5个文章（因为可能为多图文），3表示5个中的第3个</td>
</tr>
<tr>
<td style="text-align:left">&emsp;title</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文消息的标题</td>
</tr>
<tr>
<td style="text-align:left">&emsp;url</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">文章链接</td>
</tr>
<tr>
<td style="text-align:left">&emsp;details</td>
<td style="text-align:left">List</td>
<td style="text-align:left">R</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;stat_date</td>
<td style="text-align:left">String</td>
<td style="text-align:left">R</td>
<td style="text-align:left">统计日期</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;target_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">送达人数，一般约等于总粉丝数（需排除黑名单或其他异常情况下无法收到消息的粉丝）</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页（点击群发图文卡片进入的页面）的阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;ori_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页（点击图文页“阅读原文”进入的页面）的阅读人数，无原文页时此处数据为0</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;ori_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;share_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;share_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;add_to_fav_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;add_to_fav_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_session_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">公众号会话阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_session_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">公众号会话阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_hist_msg_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">历史消息页阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_hist_msg_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">历史消息页阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_feed_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">朋友圈阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_feed_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">朋友圈阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_friends_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">好友转发阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_friends_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">好友转发阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_other_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">其他场景阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;int_page_from_other_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">其他场景阅读次数 </td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_session_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">公众号会话转发朋友圈人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_session_cnt</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">公众号会话转发朋友圈次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_feed_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">朋友圈转发朋友圈人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_feed_cnt</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">朋友圈转发朋友圈次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_other_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">其他场景转发朋友圈人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;&emsp;feed_share_from_other_cnt</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">其他场景转发朋友圈次数</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">            &quot;msgid&quot;: &quot;2247492959_1&quot;,</span><br><span class="line">            &quot;title&quot;: &quot;高德地图高居地图导航市场首位&quot;,</span><br><span class="line">            &quot;user_source&quot;: 0,</span><br><span class="line">            &quot;details&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;stat_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">                    &quot;target_user&quot;: 11,</span><br><span class="line">                    &quot;int_page_read_user&quot;: 3,</span><br><span class="line">                    &quot;int_page_read_count&quot;: 3,</span><br><span class="line">                    &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">                    &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">                    &quot;share_user&quot;: 0,</span><br><span class="line">                    &quot;share_count&quot;: 0,</span><br><span class="line">                    &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">                    &quot;add_to_fav_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_session_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_session_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_hist_msg_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_hist_msg_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_feed_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_feed_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_friends_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_friends_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_other_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_other_read_count&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_session_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_session_cnt&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_feed_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_feed_cnt&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_other_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_other_cnt&quot;: 0</span><br><span class="line">                &#125;,</span><br><span class="line">                //...</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;stat_date&quot;: &quot;2019-12-19&quot;,</span><br><span class="line">                    &quot;target_user&quot;: 11,</span><br><span class="line">                    &quot;int_page_read_user&quot;: 13,</span><br><span class="line">                    &quot;int_page_read_count&quot;: 13,</span><br><span class="line">                    &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">                    &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">                    &quot;share_user&quot;: 0,</span><br><span class="line">                    &quot;share_count&quot;: 0,</span><br><span class="line">                    &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">                    &quot;add_to_fav_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_session_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_session_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_hist_msg_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_hist_msg_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_feed_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_feed_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_friends_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_friends_read_count&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_other_read_user&quot;: 0,</span><br><span class="line">                    &quot;int_page_from_other_read_count&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_session_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_session_cnt&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_feed_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_feed_cnt&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_other_user&quot;: 0,</span><br><span class="line">                    &quot;feed_share_from_other_cnt&quot;: 0</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;url&quot;: &quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjE2MjM5Ng==&amp;mid=2247492959&amp;idx=1&amp;sn=a404969ce0387803efdc0d325ac2a494#rd&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-获取图文统计数据（getuserread）"><a href="#1-3-获取图文统计数据（getuserread）" class="headerlink" title="1.3 获取图文统计数据（getuserread）"></a>1.3 获取图文统计数据（getuserread）</h3><ul>
<li><strong>接口地址：</strong><br><code>https://api.weixin.qq.com/datacube/getuserread?access_token=ACCESS_TOKEN</code></li>
</ul>
<h4 id="1-3-1-请求参数"><a href="#1-3-1-请求参数" class="headerlink" title="1.3.1 请求参数"></a>1.3.1 请求参数</h4><ul>
<li>请求示例：（最大时间跨：<strong>3</strong> ）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;begin_date&quot;: &quot;2019-12-12&quot;, </span><br><span class="line">    &quot;end_date&quot;: &quot;2019-12-14&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-返回结果"><a href="#1-3-2-返回结果" class="headerlink" title="1.3.2 返回结果"></a>1.3.2 返回结果</h4><table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">出现要求</th>
<th style="text-align:left">描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">list&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">List</td>
<td style="text-align:left">R&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ref_date</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">数据的日期，需在begin_date和end_date之间</td>
</tr>
<tr>
<td style="text-align:left">&emsp;user_source</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">在获取图文阅读分时数据时才有该字段，代表用户从哪里进入来阅读该图文。0:会话;1.好友;2.朋友圈;3.腾讯微博;4.历史消息页;5.其他;6.看一看;7.搜一搜</td>
</tr>
<tr>
<td style="text-align:left">&emsp;int_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页（点击群发图文卡片进入的页面）的阅读人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;int_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">图文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ori_page_read_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页（点击图文页“阅读原文”进入的页面）的阅读人数，无原文页时此处数据为0</td>
</tr>
<tr>
<td style="text-align:left">&emsp;ori_page_read_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">原文页的阅读次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;share_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;share_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">分享的次数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;add_to_fav_user</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的人数</td>
</tr>
<tr>
<td style="text-align:left">&emsp;add_to_fav_count</td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">收藏的次数</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-12&quot;,</span><br><span class="line">            &quot;user_source&quot;: 7,</span><br><span class="line">            &quot;int_page_read_user&quot;: 2,</span><br><span class="line">            &quot;int_page_read_count&quot;: 2,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-13&quot;,</span><br><span class="line">            &quot;user_source&quot;: 7,</span><br><span class="line">            &quot;int_page_read_user&quot;: 9,</span><br><span class="line">            &quot;int_page_read_count&quot;: 10,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ref_date&quot;: &quot;2019-12-14&quot;,</span><br><span class="line">            &quot;user_source&quot;: 7,</span><br><span class="line">            &quot;int_page_read_user&quot;: 3,</span><br><span class="line">            &quot;int_page_read_count&quot;: 3,</span><br><span class="line">            &quot;ori_page_read_user&quot;: 0,</span><br><span class="line">            &quot;ori_page_read_count&quot;: 0,</span><br><span class="line">            &quot;share_user&quot;: 0,</span><br><span class="line">            &quot;share_count&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_user&quot;: 0,</span><br><span class="line">            &quot;add_to_fav_count&quot;: 0</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-附录B-响应码说明"><a href="#2-附录B-响应码说明" class="headerlink" title="2 附录B 响应码说明"></a>2 附录B 响应码说明</h2><table>
<thead>
<tr>
<th style="text-align:left">响应码</th>
<th style="text-align:left">说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">42001</td>
<td style="text-align:left">access_token 失效</td>
</tr>
<tr>
<td style="text-align:left">61501</td>
<td style="text-align:left">date range error 时间跨度错误</td>
</tr>
</tbody>
</table>
<h2 id="3-附录A-响应码说明"><a href="#3-附录A-响应码说明" class="headerlink" title="3 附录A 响应码说明"></a>3 附录A 响应码说明</h2><h4 id="3-1-1-请求参数"><a href="#3-1-1-请求参数" class="headerlink" title="3.1.1 请求参数"></a>3.1.1 请求参数</h4><table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">出现要求</th>
<th style="text-align:left">描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">access_token</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R&emsp;&emsp;&emsp;&emsp;</td>
<td style="text-align:left">调用接口凭证</td>
</tr>
<tr>
<td style="text-align:left">begin_date</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">获取数据的起始日期，begin_date和end_date的差值需小于“最大时间跨度”（比如最大时间跨度为1时，begin_date和end_date的差值只能为0，才能小于1），否则会报错</td>
</tr>
<tr>
<td style="text-align:left">end_date</td>
<td style="text-align:left">string</td>
<td style="text-align:left">R</td>
<td style="text-align:left">获取数据的结束日期，end_date允许设置的最大值为昨日</td>
</tr>
</tbody>
</table>
<ul>
<li>最大时间跨度是指一次接口调用时最大可获取数据的时间范围，如最大时间跨度为7是指最多一次性获取7天的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、接口侧的公众号数据的数据库中仅存储了2014年12月1日之后的数据，将查询不到在此之前的日期，即使有查到，也是不可信的脏数据；</span><br><span class="line">2、请开发者在调用接口获取数据后，将数据保存在自身数据库中，即加快下次用户的访问速度，也降低了微信侧接口调用的不必要损耗。</span><br><span class="line">3、额外注意，获取图文群发每日数据接口的结果中，只有中间页阅读人数+原文页阅读人数+分享转发人数+分享转发次数+收藏次数 &gt;=3的结果才会得到统计，过小的阅读量的图文消息无法统计。</span><br><span class="line">4、为确保公众号数据已完成统计和处理，请于每天上午8点后查询公众号前一天的数据。</span><br></pre></td></tr></table></figure>
<ul>
<li>如果查询当天数据会报61501</li>
</ul>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(1)--不使用加号实现 A+B go语言实现</title>
    <url>/2019/08/23/%E7%AE%97%E6%B3%951/</url>
    <content><![CDATA[<p>Go 不使用加号实现 A+B，此问题来自： <a href="https://www.lintcode.com/problem/a-b-problem/description" target="_blank" rel="noopener">lintcode</a></p>
<a id="more"></a>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>说明<br>a和b都是 32位 整数么？</p>
<p>是的<br>我可以使用位运算符么？</p>
<p>当然可以<br>样例<br>如果 a=1 并且 b=2，返回3。</p>
<p>挑战<br>显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）<br><!-- more --></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Go代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := aplusb(<span class="number">5</span>, <span class="number">17</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aplusb</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x1 := a ^ b</span><br><span class="line">	x2 := (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> aplusb(x1, x2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> jw=a&amp;b;</span><br><span class="line"> <span class="keyword">int</span> jg=a^b;</span><br><span class="line"> <span class="keyword">while</span>(jw)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">int</span> t_a=jg;</span><br><span class="line">  <span class="keyword">int</span> t_b=jw&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  jw=t_a&amp;t_b;</span><br><span class="line">  jg=t_a^t_b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> jg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * param a: The first integer</span></span><br><span class="line"><span class="comment">     * param b: The second integer</span></span><br><span class="line"><span class="comment">     * return: The sum of a and b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要利用异或运算来完成 </span></span><br><span class="line">        <span class="comment">// 异或运算有一个别名叫做：不进位加法</span></span><br><span class="line">        <span class="comment">// 那么a ^ b就是a和b相加之后，该进位的地方不进位的结果</span></span><br><span class="line">        <span class="comment">// 然后下面考虑哪些地方要进位，自然是a和b里都是1的地方</span></span><br><span class="line">        <span class="comment">// a &amp; b就是a和b里都是1的那些位置，a &amp; b &lt;&lt; 1 就是进位</span></span><br><span class="line">        <span class="comment">// 之后的结果。所以：a + b = (a ^ b) + (a &amp; b &lt;&lt; 1)</span></span><br><span class="line">        <span class="comment">// 令a' = a ^ b, b' = (a &amp; b) &lt;&lt; 1</span></span><br><span class="line">        <span class="comment">// 可以知道，这个过程是在模拟加法的运算过程，进位不可能</span></span><br><span class="line">        <span class="comment">// 一直持续，所以b最终会变为0。因此重复做上述操作就可以</span></span><br><span class="line">        <span class="comment">// 求得a + b的值。</span></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> _a = a ^ b;</span><br><span class="line">            <span class="keyword">int</span> _b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = _a;</span><br><span class="line">            b = _b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>##分析<br>用位运算实现加法也就是计算机用二进制进行运算，32位的CPU只能表示32位内的数，这里先用1位数的加法来进行，在不考虑进位的基础上，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 1 = 0</span><br><span class="line">1 + 0 = 1</span><br><span class="line">0 + 1 = 1</span><br><span class="line">0 + 0 = 0</span><br></pre></td></tr></table></figure>
<p>很明显这几个表达式可以用位运算的“^”来代替（不考虑进位的情况下位运算符中的异或^可以表示+号），如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">0 ^ 0 = 0</span><br></pre></td></tr></table></figure>
<p>这样我们就完成了简单的一位数加法，那么要进行二位的加法，这个方法可行不可行呢？肯定是不行的，矛盾就在于，如何去<br>获取进位？要获取进位我们可以如下思考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 + 0 = 0</span><br><span class="line">1 + 0 = 0</span><br><span class="line">0 + 1 = 0</span><br><span class="line">1 + 1 = 1</span><br><span class="line">//换个角度看就是这样</span><br><span class="line">0 &amp; 0 = 不进位</span><br><span class="line">1 &amp; 0 = 不进位</span><br><span class="line">0 &amp; 1 = 不进位</span><br><span class="line">1 &amp; 1 = 进位</span><br></pre></td></tr></table></figure>
<p>正好，在位运算中，我们用“&lt;&lt;”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式</p>
<p>//进位可以用如下表示：（位运算符中的与运算符&amp;和左移运算符&lt;&lt;可以模拟加法中的进位）<br><code>(x&amp;y)&lt;&lt;1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">到这里，我们基本上拥有了这样两个表达式</span><br><span class="line"></span><br><span class="line">x^y //执行加法</span><br><span class="line">(x&amp;y)&lt;&lt;1 //进位操作</span><br><span class="line">我们来做个2位数的加法，在不考虑进位的情况下</span><br><span class="line"></span><br><span class="line">11+01 = 100  // 本来的算法</span><br><span class="line"> </span><br><span class="line">// 用推算的表达式计算</span><br><span class="line">11 ^ 01 = 10</span><br><span class="line"> </span><br><span class="line">(11 &amp; 01) &lt;&lt; 1 = 10</span><br><span class="line"> </span><br><span class="line">//到这里 我们用普通的加法去运算这两个数的时候就可以得到 10 + 10 = 100</span><br><span class="line">//但是我们不需要加法，所以要想别的方法，如果让两个数再按刚才的算法计算一次呢</span><br><span class="line">10 ^ 10 = 00</span><br><span class="line"> </span><br><span class="line">(10 &amp; 10) &lt;&lt; 1 = 100</span><br><span class="line">到这里基本上就得出结论了，其实后面的那个 “00” 已经不用再去计算了，因为第一个表达式就已经算出了结果。</span><br><span class="line"></span><br><span class="line">继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果。</span><br></pre></td></tr></table></figure>
<p>##现总结如下:</p>
<ol>
<li><em>定理1</em>：设a，b为两个二进制数，则a+b = a^b + (a&amp;b)&lt;&lt;1。<br> <em>证明</em>：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&amp;b)&lt;&lt;1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。</li>
<li><em>定理2</em>：使用定理1可以实现只用位运算进行加法运算。<br> <em>证明</em>：利用定理1中的等式不停对自身进行迭代。每迭代一次，进位补偿右边就多一位0，因此最多需要加数二进制位长度次迭代，进位补偿就变为0，这时运算结束。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j使用 &amp;&amp; Intellij Idea打jar包</title>
    <url>/2019/08/01/log4j%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、log4j-使用"><a href="#一、log4j-使用" class="headerlink" title="一、log4j 使用"></a>一、log4j 使用</h1><ul>
<li>首先引入log4j</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置文件 log4j.properties</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#日志级别,输出目的地  </span><br><span class="line">log4j.rootLogger=DEBUG,stdout,logFile</span><br><span class="line"></span><br><span class="line">### 输出信息到控制抬 ###</span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l]: %m%n</span><br><span class="line"></span><br><span class="line">##logFile log</span><br><span class="line">log4j.appender.logFile = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logFile.layout.ConversionPattern = [%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l]: %m%n</span><br><span class="line">log4j.appender.logFile.Threshold = DEBUG</span><br><span class="line">log4j.appender.logFile.ImmediateFlush = TRUE</span><br><span class="line">log4j.appender.logFile.Append = TRUE</span><br><span class="line">log4j.appender.logFile.File = ./local_files/logs/$&#123;log.file&#125;</span><br><span class="line">log4j.appender.logFile.Encoding = UTF-8</span><br><span class="line"></span><br><span class="line">#CommonLog log</span><br><span class="line">log4j.logger.CommonLog=INFO,CommonLog,CommonStdout</span><br><span class="line">#如果additivity设置为false  就不想父logger打印</span><br><span class="line">log4j.additivity.CommonLog = false</span><br><span class="line"></span><br><span class="line">log4j.appender.CommonStdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CommonStdout.Target = System.out</span><br><span class="line">log4j.appender.CommonStdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CommonStdout.layout.ConversionPattern=[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l]: %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.CommonLog =org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">#log4j.appender.CommonLog.File= ./local_files/logs/common_log.txt</span><br><span class="line">log4j.appender.CommonLog.File= ./local_files/logs/$&#123;common_log.file&#125;</span><br><span class="line">#log4j.appender.CommonLog.File= $&#123;log.dir&#125;/$&#123;common_log.file&#125;</span><br><span class="line">#System.setProperty(“log.dir”, logDir);</span><br><span class="line">#System.setProperty(“common_log.file”, infoLogFileName);</span><br><span class="line">log4j.appender.CommonLog.DatePattern=&apos;_&apos;yyyy-MM-dd-HH&apos;.txt&apos;</span><br><span class="line">#log4j.appender.CommonLog.Threshold=INFO</span><br><span class="line">log4j.appender.CommonLog.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CommonLog.layout.ConversionPattern=[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l] : %m%n</span><br><span class="line"></span><br><span class="line">#ExceptionLog log</span><br><span class="line">log4j.logger.ExceptionLog=INFO,ExceptionLog,ExceptionStdout</span><br><span class="line">log4j.additivity.ExceptionLog = false</span><br><span class="line"></span><br><span class="line">log4j.appender.ExceptionStdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.ExceptionStdout.Target = System.out</span><br><span class="line">log4j.appender.ExceptionStdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.ExceptionStdout.layout.ConversionPattern=[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l]: %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.ExceptionLog =org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.ExceptionLog.File= ./local_files/logs/$&#123;exception_log.file&#125;</span><br><span class="line">#log4j.appender.ExceptionLog.File= ./local_files/logs/exception_log.txt</span><br><span class="line">log4j.appender.ExceptionLog.DatePattern=&apos;_&apos;yyyy-MM-dd-HH&apos;.txt&apos;</span><br><span class="line">#log4j.appender.ExceptionLog.Threshold=INFO</span><br><span class="line">log4j.appender.ExceptionLog.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.ExceptionLog.layout.ConversionPattern=[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l] : %m%n</span><br><span class="line">#[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l][%c] : %m%n</span><br><span class="line">#[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%l] : %m%n</span><br></pre></td></tr></table></figure>
<ul>
<li>使用方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Logger getCommonLogger()&#123;</span><br><span class="line">    if (null == commonLogger)&#123;</span><br><span class="line">        System.setProperty(&quot;log.file&quot;, getLogName());</span><br><span class="line">        System.setProperty(&quot;common_log.file&quot;, getCommonLogName());</span><br><span class="line">        System.setProperty(&quot;exception_log.file&quot;, getExceptionLogName());</span><br><span class="line">	  //如果没有放到默认路径下，则需要如下加载方式</span><br><span class="line">	  //PropertyConfigurator.configure(&quot;log4j.properties&quot;);</span><br><span class="line">        commonLogger = Logger.getLogger(&quot;CommonLog&quot;);</span><br><span class="line">        if (IS_DEV)&#123;</span><br><span class="line">            commonLogger.setLevel(Level.DEBUG);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            commonLogger.setLevel(Level.INFO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return commonLogger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这样调用</span><br><span class="line">//MyLogger.getCommonLogger().debug(&quot;getCommonLogger&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-解决log4j-properties不起作用的问题"><a href="#1-解决log4j-properties不起作用的问题" class="headerlink" title="1. 解决log4j.properties不起作用的问题"></a>1. 解决log4j.properties不起作用的问题</h3><ol>
<li>如果没有放到默认路径下，则需要如下加载方式<br> PropertyConfigurator.configure(“log4j.properties”);</li>
<li>在main文件夹下创建resources文件夹，将log4j.properties放到该文件夹下解决</li>
</ol>
<h3 id="2-解决log4j-properties打不到jar包中的问题"><a href="#2-解决log4j-properties打不到jar包中的问题" class="headerlink" title="2. 解决log4j.properties打不到jar包中的问题"></a>2. 解决log4j.properties打不到jar包中的问题</h3><ol>
<li>同样是因为没有放到默认的路径中</li>
<li>在main文件夹下创建resources文件夹，将log4j.properties放到该文件夹下解决</li>
</ol>
<h1 id="二、Intellij-idea-打jar包"><a href="#二、Intellij-idea-打jar包" class="headerlink" title="二、Intellij idea  打jar包"></a>二、Intellij idea  打jar包</h1><ul>
<li><p>在File -&gt; project Structure （command+；）-&gt;选择Artifacts-&gt;点击＋<br>-&gt; 选择jar  -&gt;  选择From modules with Dependencies.</p>
</li>
<li><p>选择执行的主类 main class：<br>选择“extract to the target jar”，即把引用第三方的jar文件，同时打包到jar里。</p>
</li>
<li><p>配置“Directory for META-INF/MAINFEST.MF”<br><strong>需要改成：项目根目录！！！项目根目录！！！项目根目录！！！（反正不能放在原来默认的目录下面）</strong>如果根目录已经有了，就删掉</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体配置详细：</span><br><span class="line">Module： 模块，选择需要打包的模块。如果程序没有分模块，那么只有一个可以选择的。</span><br><span class="line">MainClass：选择程序的入口类。</span><br><span class="line">extract to the target JAR：抽取到目标JAR。选择该项则会将所依赖的jar包全都打到一个jar文件中。</span><br><span class="line">copy to the output directory and link via manifest：将依赖的jar复制到输出目录并且使用manifest链接它们。</span><br><span class="line">Direct for META-INF/MANIFEST.MF： 如果上面选择了 &quot;copy to ... &quot;这一项，这里需要选择生成的manifest文件在哪个目录下。</span><br><span class="line">Include tests： 是否包含tests。 一般这里不选即可。</span><br></pre></td></tr></table></figure>
<ul>
<li>点击ok进入下一步</li>
<li>此页直接点击apply–&gt;ok即可（name是jar包名字，output directory是jar包生成的地址，type是类型）</li>
<li>点击Build —&gt; Build Artifacts..  —&gt;  Build 即可执行打包命令</li>
<li>最后在此目录下找到打好的jar包。</li>
<li>运行java -jar xxxx.jar 命令即可。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>window环境 exe在后台运行</title>
    <url>/2019/07/24/window%E7%8E%AF%E5%A2%83%20exe%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="2019-7-24"><a href="#2019-7-24" class="headerlink" title="2019-7-24"></a>2019-7-24</h1><h2 id="1-window环境-exe在后台运行"><a href="#1-window环境-exe在后台运行" class="headerlink" title="1.window环境 exe在后台运行"></a>1.window环境 exe在后台运行</h2><p><a href="https://blog.csdn.net/lendq/article/details/80283268" target="_blank" rel="noopener">Windows下程序后台执行文件</a> </p>
<a id="more"></a>
<ul>
<li>.bat文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;%1&quot;==&quot;h&quot; goto begin</span><br><span class="line">start mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit</span><br><span class="line">:begin</span><br><span class="line">xxxxx 要执行的命令</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;%~nx0 h&quot;,0中的%~nx0是把批处理自己的文件名传送给vbs，以便让vbs隐藏打开它。h是设置隐藏属性，0为隐藏运行。window.close是关闭窗口（可以说是关闭vbs）。  不加if &quot;%1&quot; == &quot;h&quot; goto begin会导致崩溃是因为要检查批处理是否隐藏了，如果隐藏则跳到“begin”（中文名为“开始”）执行。不然的话系统就会以为批处理没有隐藏，没有返回结果而不停地工作，调用程序。</span><br></pre></td></tr></table></figure>
<ul>
<li>.vbs文件<br>保存成.vbs文件，直接运行.vbs文件即可实现后台运行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set wscriptObj = CreateObject(&quot;Wscript.Shell&quot;)   </span><br><span class="line">wscriptObj.run &quot;xxx要执行的命令&quot;,0</span><br></pre></td></tr></table></figure>
<ul>
<li>开机自启动<br>将.vbs文件的快捷方式 复制到如下目录<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp<ul>
<li>这种方式只能是系统登陆以后，进入桌面才会启动</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/szjy8/article/details/83297408" target="_blank" rel="noopener">小小分享 偷偷在后台运行程序vbs</a> </p>
<h2 id="2-一些命令"><a href="#2-一些命令" class="headerlink" title="2. 一些命令"></a>2. 一些命令</h2><ol>
<li>rm -rf /data  会删掉data目录以及子目录下的所有文件 （慎用，文件名一定要搞对，所删除的文件，一般都不能恢复！）</li>
<li><p>Linux下的tar压缩解压缩命令详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar</span><br><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br><span class="line"></span><br><span class="line">这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</span><br><span class="line">===================================</span><br><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br><span class="line">===================================</span><br><span class="line">下面的参数-f是必须的</span><br><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br><span class="line"># tar -cf all.tar *.jpg</span><br><span class="line">这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span><br><span class="line"># tar -rf all.tar *.gif</span><br><span class="line">这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</span><br><span class="line"># tar -uf all.tar logo.gif</span><br><span class="line">这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</span><br><span class="line"># tar -tf all.tar</span><br><span class="line">这条命令是列出all.tar包中所有文件，-t是列出文件的意思</span><br><span class="line"># tar -xf all.tar</span><br><span class="line">这条命令是解出all.tar包中所有文件，-t是解开的意思</span><br><span class="line">===================================</span><br><span class="line">压缩</span><br><span class="line">tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar </span><br><span class="line">tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line">tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span><br><span class="line">tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux</span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</span><br><span class="line">===================================</span><br><span class="line">解压</span><br><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">tar -xZvf file.tar.Z   //解压tar.Z</span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line">unzip file.zip //解压zip</span><br><span class="line">===================================</span><br><span class="line">总结</span><br><span class="line">1、*.tar 用 tar -xvf 解压</span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压</span><br><span class="line">3、*.tar.gz和*.tgz 用 tar -xzf 解压</span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压	</span><br><span class="line">5、*.tar.bz2用tar -xjf 解压</span><br><span class="line">6、*.Z 用 uncompress 解压</span><br><span class="line">7、*.tar.Z 用tar -xZf 解压</span><br><span class="line">8、*.rar 用 unrar e解压</span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/qq_30548105/article/details/72676245" target="_blank" rel="noopener">手把手教你破解微信本地数据库(利用Sqlcipher查看)</a><br><a href="https://notes.zz-zigzag.com/2017/09/wechat-db.html" target="_blank" rel="noopener">使用微信聊天记录统计信息</a><br><a href="https://www.zhihu.com/question/19924224" target="_blank" rel="noopener">如何备份微信的聊天记录？</a><br><a href="https://blog.csdn.net/u011195398/article/details/85266214" target="_blank" rel="noopener">Mac终端使用Sqlcipher加解密基础过程详解</a>  </p>
</li>
</ol>
<ol start="4">
<li><a href="https://www.cnblogs.com/linguanh/p/8323487.html" target="_blank" rel="noopener">全面总结： Golang 调用 C/C++，例子式教程</a></li>
<li><a href="https://blog.csdn.net/u011596455/article/details/80073841" target="_blank" rel="noopener">Go实现海量日志收集系统</a></li>
<li><a href="https://imgki.com/archives/62.html" target="_blank" rel="noopener">超强内网穿透nps 解决所有无公网IP问题</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 配置</title>
    <url>/2019/07/18/Golang%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="学习1"><a href="#学习1" class="headerlink" title="学习1"></a>学习1</h1><h3 id="2019-7-18"><a href="#2019-7-18" class="headerlink" title="2019-7-18"></a>2019-7-18</h3><ol>
<li><p>重复的事情进行思考总结，磨刀不误砍柴工！</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gotest</span><br><span class="line">gotest</span><br><span class="line">gotest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h3 id="2019-7-19"><a href="#2019-7-19" class="headerlink" title="2019-7-19"></a>2019-7-19</h3><ol>
<li>在 go.mod 文件下面添加如下可替换本地库</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replace golang.org/x/crypto =&gt; ../golang.org/x/crypto</span><br><span class="line"></span><br><span class="line">replace golang.org/x/sync =&gt; ../golang.org/x/sync</span><br><span class="line"></span><br><span class="line">replace golang.org/x/net =&gt; ../golang.org/x/net</span><br><span class="line"></span><br><span class="line">replace golang.org/x/sys =&gt; ../golang.org/x/sys</span><br><span class="line"></span><br><span class="line">replace golang.org/x/text =&gt; ../golang.org/x/text</span><br><span class="line"></span><br><span class="line">replace golang.org/x/tools =&gt; ../golang.org/x/tools</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p>替换远程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replace (</span><br><span class="line">	cloud.google.com/go =&gt; github.com/googleapis/google-cloud-go v0.34.0</span><br><span class="line">	github.com/go-tomb/tomb =&gt; gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7</span><br><span class="line">	go.opencensus.io =&gt; github.com/census-instrumentation/opencensus-go v0.19.0</span><br><span class="line">	go.uber.org/atomic =&gt; github.com/uber-go/atomic v1.3.2</span><br><span class="line">	go.uber.org/multierr =&gt; github.com/uber-go/multierr v1.1.0</span><br><span class="line">	go.uber.org/zap =&gt; github.com/uber-go/zap v1.9.1</span><br><span class="line">	golang.org/x/crypto =&gt; github.com/golang/crypto v0.0.0-20181001203147-e3636079e1a4</span><br><span class="line">	golang.org/x/lint =&gt; github.com/golang/lint v0.0.0-20181026193005-c67002cb31c3</span><br><span class="line">	golang.org/x/net =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d</span><br><span class="line">	golang.org/x/oauth2 =&gt; github.com/golang/oauth2 v0.0.0-20180821212333-d2e6202438be</span><br><span class="line">	golang.org/x/sync =&gt; github.com/golang/sync v0.0.0-20181108010431-42b317875d0f</span><br><span class="line">	golang.org/x/sys =&gt; github.com/golang/sys v0.0.0-20181116152217-5ac8a444bdc5</span><br><span class="line">	golang.org/x/text =&gt; github.com/golang/text v0.3.0</span><br><span class="line">	golang.org/x/time =&gt; github.com/golang/time v0.0.0-20180412165947-fbb02b2291d2</span><br><span class="line">	golang.org/x/tools =&gt; github.com/golang/tools v0.0.0-20181219222714-6e267b5cc78e</span><br><span class="line">	google.golang.org/api =&gt; github.com/googleapis/google-api-go-client v0.0.0-20181220000619-583d854617af</span><br><span class="line">	google.golang.org/appengine =&gt; github.com/golang/appengine v1.3.0</span><br><span class="line">	google.golang.org/genproto =&gt; github.com/google/go-genproto v0.0.0-20181219182458-5a97ab628bfb</span><br><span class="line">	google.golang.org/grpc =&gt; github.com/grpc/grpc-go v1.17.0</span><br><span class="line">	gopkg.in/alecthomas/kingpin.v2 =&gt; github.com/alecthomas/kingpin v2.2.6+incompatible</span><br><span class="line">	gopkg.in/mgo.v2 =&gt; github.com/go-mgo/mgo v0.0.0-20180705113604-9856a29383ce</span><br><span class="line">	gopkg.in/vmihailenco/msgpack.v2 =&gt; github.com/vmihailenco/msgpack v2.9.1+incompatible</span><br><span class="line">	gopkg.in/yaml.v2 =&gt; github.com/go-yaml/yaml v0.0.0-20181115110504-51d6538a90f8</span><br><span class="line">	labix.org/v2/mgo =&gt; github.com/go-mgo/mgo v0.0.0-20160801194620-b6121c6199b7</span><br><span class="line">	launchpad.net/gocheck =&gt; github.com/go-check/check v0.0.0-20180628173108-788fd7840127</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">主要包括:</span><br><span class="line">golang.org</span><br><span class="line">google.golang.org</span><br><span class="line">gopkg.in</span><br><span class="line">go.uber.org</span><br><span class="line">cloud.google.com在下载包时会有timeout 导致编译失败，以上是对应的github的库</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis 外网无法访问的问题</p>
<ul>
<li>安装完以后，需要打开6379端口</li>
<li>redis-server默认开放的127.0.0.1 IP地址需要修改为0.0.0.0才可以被其他机器访问<ul>
<li>1、在Redis安装目录下找到配置文件 redis.config</li>
<li>2、修改 bind 127.0.0.1 改为 bind 0.0.0.0 </li>
<li>3、重启Redis服务</li>
</ul>
</li>
</ul>
</li>
<li><p>学习golang的一些知名库</p>
<ul>
<li><p>Logrus (go get github.com/sirupsen/logrus)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  log &quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">)</span><br><span class="line">func init() &#123;</span><br><span class="line">	log.SetFormatter(&amp;log.JSONFormatter&#123;</span><br><span class="line">		PrettyPrint: false,</span><br><span class="line">	&#125;)</span><br><span class="line">	log.SetLevel(log.InfoLevel)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  log.WithFields(log.Fields&#123;</span><br><span class="line">    &quot;animal&quot;: &quot;walrus&quot;,</span><br><span class="line">  &#125;).Info(&quot;A walrus appears&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>yaml (go get gopkg.in/yaml.v2)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host: localhost:3306</span><br><span class="line">user: root</span><br><span class="line">pwd: 123456</span><br><span class="line">dbname: test</span><br><span class="line">Redis:</span><br><span class="line">  Addr: 140.143.224.224:6379 # redis链接</span><br><span class="line">  Password:   #redis 密码</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;gopkg.in/yaml.v2&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var c conf</span><br><span class="line">   conf:=c.getConf()</span><br><span class="line">   fmt.Println(conf.Host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//profile variables</span><br><span class="line">type conf struct &#123;</span><br><span class="line">    Host string `yaml:&quot;host&quot;`</span><br><span class="line">    User string `yaml:&quot;user&quot;`</span><br><span class="line">    Pwd string `yaml:&quot;pwd&quot;`</span><br><span class="line">    Dbname string `yaml:&quot;dbname&quot;`</span><br><span class="line">    // redis</span><br><span class="line">	Redis struct &#123;</span><br><span class="line">		Addr     string `yaml:&quot;Addr&quot;`     // redis链接</span><br><span class="line">		Password string `yaml:&quot;Password&quot;` //redis 密码</span><br><span class="line">	&#125; `yaml:&quot;Redis&quot;`</span><br><span class="line">&#125;</span><br><span class="line">func (c *conf) getConf() *conf &#123;</span><br><span class="line">    yamlFile, err := ioutil.ReadFile(&quot;conf.yaml&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    err = yaml.Unmarshal(yamlFile, c)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol start="5">
<li>scss文件转换css <ul>
<li><a href="https://www.sass.hk/install/" target="_blank" rel="noopener">https://www.sass.hk/install/</a><ul>
<li>命令 sass –watch inputdir:outputdir</li>
</ul>
</li>
</ul>
</li>
<li><p>vscode setting.json</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#123;</span><br><span class="line">    &quot;java.errors.incompleteClasspath.severity&quot;: &quot;ignore&quot;,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 1,</span><br><span class="line">    &quot;editor.minimap.enabled&quot;: false,</span><br><span class="line">    &quot;editor.suggestSelection&quot;: &quot;first&quot;,</span><br><span class="line">    &quot;vsintellicode.modify.editor.suggestSelection&quot;: &quot;automaticallyOverrodeDefaultValue&quot;,</span><br><span class="line">    &quot;git.autofetch&quot;: false,</span><br><span class="line">    &quot;files.autoSave&quot;: &quot;afterDelay&quot;,</span><br><span class="line">    &quot;java.configuration.checkProjectSettingsExclusions&quot;: false,</span><br><span class="line">    &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">    //===============go setting=======================</span><br><span class="line">    // &quot;go.formatTool&quot;: &quot;goimports&quot;,</span><br><span class="line">    &quot;go.inferGopath&quot;: false,</span><br><span class="line">    &quot;go.buildOnSave&quot;: &quot;workspace&quot;,</span><br><span class="line">    &quot;go.lintOnSave&quot;: &quot;package&quot;,</span><br><span class="line">    &quot;go.vetOnSave&quot;: &quot;package&quot;,</span><br><span class="line">    &quot;go.buildTags&quot;: &quot;&quot;,</span><br><span class="line">    &quot;go.buildFlags&quot;: [],</span><br><span class="line">    &quot;go.lintFlags&quot;: [&quot;--disable=all&quot;, &quot;--enable=errcheck&quot;],</span><br><span class="line">    &quot;go.vetFlags&quot;: [],</span><br><span class="line">    &quot;go.coverOnSave&quot;: false,</span><br><span class="line">    &quot;go.useCodeSnippetsOnFunctionSuggest&quot;: false,</span><br><span class="line">//     &quot;go.formatOnSave&quot;: true,</span><br><span class="line">    &quot;go.formatTool&quot;: &quot;goreturns&quot;,</span><br><span class="line">    &quot;go.goroot&quot;: &quot;/usr/local/go&quot;,</span><br><span class="line">    &quot;go.gocodeAutoBuild&quot;: false,</span><br><span class="line">    &quot;go.useLanguageServer&quot;: true</span><br><span class="line">//     &quot;go.alternateTools&quot;: &#123;</span><br><span class="line">//       &quot;go-langserver&quot;: &quot;gopls&quot;, </span><br><span class="line">//     &#125;</span><br><span class="line">//     &quot;go.languageServerExperimentalFeatures&quot;: &#123;</span><br><span class="line">//       &quot;format&quot;: true,</span><br><span class="line">//       &quot;autoComplete&quot;: true</span><br><span class="line">//     &#125;,</span><br><span class="line">//     &quot;[go]&quot;: &#123;</span><br><span class="line">//         &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">//             &quot;source.organizeImports&quot;: true</span><br><span class="line">//         &#125;,</span><br><span class="line">//     &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	环境变量设置：</span><br><span class="line">	export GO111MODULE=on</span><br></pre></td></tr></table></figure>
</li>
<li><p>go build</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Golang 支持在一个平台下生成另一个平台可执行程序的交叉编译功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mac下编译Linux, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Linux下编译Mac, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Windows下编译Mac, Linux平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin3</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>adb命令</title>
    <url>/2019/07/17/adb%E5%91%BD%E4%BB%A4%20/</url>
    <content><![CDATA[<h1 id="adb命令"><a href="#adb命令" class="headerlink" title="adb命令"></a>adb命令</h1><h3 id="2019-7-17"><a href="#2019-7-17" class="headerlink" title="2019-7-17"></a>2019-7-17</h3><ol>
<li>打开scheme<ul>
<li>adb shell am start -a android.intent.action.VIEW -d qqnews://article_9527?nm=20180808A083TK00</li>
</ul>
</li>
<li>查看当前页面的activity<ul>
<li><code>windows下:</code> adb shell dumpsys activity | findstr mFocus  </li>
<li><code>mic 或者 linux下:</code> adb shell dumpsys activity | grep mFocus  <a id="more"></a></li>
</ul>
</li>
<li>点击返回按钮<ul>
<li>adb shell input keyevent 4</li>
</ul>
</li>
<li>home键的点击<ul>
<li>adb shell input keyevent 3</li>
</ul>
</li>
<li>获取当前页面内容<ul>
<li>adb shell uiautomator dump</li>
</ul>
</li>
<li>单击指定的点(300,450)<ul>
<li>adb shell input tap 300 450</li>
</ul>
</li>
<li>滑动当前页面(最后一个参数是时间毫秒)<ul>
<li>adb shell input swipe 360 920 360 280 500</li>
</ul>
</li>
<li>进入指定页面(activity)<ul>
<li>adb shell am start -n com.ss.android.article.news/com.ss.android.article.news.activity.MainActivity</li>
</ul>
</li>
<li>切换到adbkeyboard输入法<ul>
<li>adb shell ime set com.android.adbkeyboard/.AdbIME</li>
</ul>
</li>
<li>adb端口重定向<ul>
<li>adb forward tcp:59254 tcp:7912</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>工作随笔</category>
      </categories>
      <tags>
        <tag>工作随笔</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android启动优化</title>
    <url>/2018/08/18/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Android-启动优化"><a href="#Android-启动优化" class="headerlink" title="Android 启动优化"></a>Android 启动优化</h2><h3 id="1-首先定义一个drawable-用于设置主题背景（android-windowBackground）"><a href="#1-首先定义一个drawable-用于设置主题背景（android-windowBackground）" class="headerlink" title="1.首先定义一个drawable 用于设置主题背景（android:windowBackground）"></a>1.首先定义一个drawable 用于设置主题背景（android:windowBackground）</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layer-list</span><br><span class="line">    android:opacity=&quot;opaque&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@color/white&quot;/&gt;</span><br><span class="line">    &lt;item &gt;</span><br><span class="line">        &lt;bitmap android:src=&quot;@drawable/icon_logo&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;/&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-设置启动页主题背景（android-windowBackground）"><a href="#2-设置启动页主题背景（android-windowBackground）" class="headerlink" title="2.设置启动页主题背景（android:windowBackground）"></a>2.设置启动页主题背景（android:windowBackground）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;app_cool_launch&quot; parent=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_cool_launch_img&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/notAnimation&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>默认情况下，所有可绘制项都会缩放以适应包含视图的大小。因此，将图像放在图层列表中的不同位置可能会增大视图的大小，并且有些图像会相应地缩放。为避免缩放列表中的项目，请在 &lt; item&gt; 元素内使用 &lt; bitmap&gt; 元素指定可绘制对象，并且对某些不缩放的项目（例如 “center”）定义重力。例如，以下 &lt; item&gt; 定义缩放以适应其容器视图的项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;item android:drawable=&quot;@drawable/image&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为避免缩放，以下示例使用重力居中的 元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;item&gt;</span><br><span class="line">    &lt;bitmap android:src=&quot;@drawable/image&quot;</span><br><span class="line">        android:gravity=&quot;center&quot; /&gt;</span><br><span class="line">&lt;/item&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>工作随笔</category>
      </categories>
      <tags>
        <tag>工作随笔</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【app】Markdown Editer 自定义格式</title>
    <url>/2018/05/18/%5Bapp%5D%20markdown%20editer/</url>
    <content><![CDATA[<p>主要是为了使用手机编写md，支持自定义格式，支持hexo所支持的格式！</p>
<p>1、功能参考markdown editer</p>
<p>2、希望加上 夜间主题 (listenerMusicplayer)</p>
<p>3、设置文件路径</p>
<p>4、使用qmui</p>
]]></content>
      <categories>
        <category>App相关</category>
      </categories>
      <tags>
        <tag>App相关</tag>
      </tags>
  </entry>
  <entry>
    <title>使用国内免费CDN加速GitHub Pages</title>
    <url>/2018/05/17/github%20page%20CDN%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<blockquote>
<p>本文描述了使用国内免费CDN<strong>【加速乐】</strong>来加速GitHub-Pages。<br><a id="more"></a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ul>
<li>我的博客使用github pages服务搭建的。国内访问速度比较慢，因此想到CDN加速。</li>
</ul>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><ul>
<li>CDN很多，但是好的服务要收费的，比如阿里云。</li>
<li>在网上找到一些免费的CDN。<a href="https://blog.csdn.net/qq_25281775/article/details/77479785" target="_blank" rel="noopener">《国内9大免费CDN汇总》</a></li>
<li>本文是使用了上面链接中的第一个：<strong>加速乐</strong>。</li>
</ul>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><ul>
<li>我的域名<code>xuezhisd.top</code>是在阿里云（万网）购买的。</li>
</ul>
<h2 id="配置加速乐"><a href="#配置加速乐" class="headerlink" title="配置加速乐"></a>配置加速乐</h2><h4 id="注册账户"><a href="#注册账户" class="headerlink" title="注册账户"></a>注册账户</h4><ul>
<li>点击<a href="https://www.yunaq.com/" target="_blank" rel="noopener">https://www.yunaq.com/</a>，填写邮箱，手机号，密码等注册。</li>
<li>根据提示，完成邮箱和手机验证。</li>
</ul>
<h4 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h4><ul>
<li>点击右侧面板的<code>域名管理</code>，然后点击<code>添加域名</code>，添加需要CDN加速的域名。</li>
<li>有两种接入方式，NS和CNAME。由于CNAME需要备案，本文选择使用NS。</li>
<li>如下图所示，已经添加了<code>xuezhisd.top</code>。</li>
</ul>
<p><img src="/images/pasted-1.png" alt="upload successful"></p>
<ul>
<li>点击域名<code>xuezhisd.top</code>，添加子域名<code>blog.xuezhisd.top</code>。如下图所示。</li>
</ul>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<h4 id="切换DNS"><a href="#切换DNS" class="headerlink" title="切换DNS"></a>切换DNS</h4><ul>
<li>点击<code>下一步，DNS切换</code>，按照提示，到阿里云上修改DNS。</li>
</ul>
<ul>
<li>在阿里云上，点击<code>DNS修改</code>，将默认的DNS修改为<code>ns1.jiasule.net</code>和<code>ns2.jiasule.net</code>。</li>
</ul>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<ul>
<li>如下图所示，点击<code>立即接入</code>，提示<strong>域名切换成功</strong>。【这需要等几分钟】<br><img src="/images/pasted-4.png" alt="upload successful"></li>
</ul>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis-ci自动化构建github+hexo博客</title>
    <url>/2018/05/16/happy/</url>
    <content><![CDATA[<p><strong>踩了好多坑，终于搞定了</strong> </p>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Android深入</title>
    <url>/2018/04/28/Android%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h2 id="明天就放假了，同事宁神要走了。告诉我一些肺腑之言，发现自己有好多待掌握的东西。"><a href="#明天就放假了，同事宁神要走了。告诉我一些肺腑之言，发现自己有好多待掌握的东西。" class="headerlink" title="明天就放假了，同事宁神要走了。告诉我一些肺腑之言，发现自己有好多待掌握的东西。"></a>明天就放假了，同事宁神要走了。告诉我一些肺腑之言，发现自己有好多待掌握的东西。</h2><h3 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h3><h3 id="2、http"><a href="#2、http" class="headerlink" title="2、http"></a>2、http</h3><pre><code>头  包体  表单（rfc1867）上传协议
</code></pre><h3 id="3、java基础"><a href="#3、java基础" class="headerlink" title="3、java基础"></a>3、java基础</h3><pre><code>java垃圾回收机制
java存储分配机制
Java各种集合  区别 使用  如何分配内存
Java类加载机制
</code></pre><h3 id="4、Android"><a href="#4、Android" class="headerlink" title="4、Android"></a>4、Android</h3><pre><code>View绘制原理
自定义View
动画
binder机制 AIDL
handler原理 looper使用（深入源码）
    HandlerThread结合intentService去看
</code></pre><h3 id="5、图片加载、优化-（glide-fresco）"><a href="#5、图片加载、优化-（glide-fresco）" class="headerlink" title="5、图片加载、优化  （glide fresco）"></a>5、图片加载、优化  （glide fresco）</h3><pre><code>图片缓存策略：三级缓存 内存 文件 
缓存回收策略：最久未使用、做不常使用。。。
线程池
glide对生命周期的控制fresco要好
</code></pre><a id="more"></a>
<h3 id="6、网络库的封装"><a href="#6、网络库的封装" class="headerlink" title="6、网络库的封装"></a>6、网络库的封装</h3><pre><code>线程池
缓存策略
参数，解析的封装
常用网络库的源码（volley okhttp okgo）
</code></pre><h3 id="7、组件化的构思"><a href="#7、组件化的构思" class="headerlink" title="7、组件化的构思"></a>7、组件化的构思</h3><h3 id="8、内存泄露的原因（长生命周期对象持有短生命周期对象的引用）以及优化"><a href="#8、内存泄露的原因（长生命周期对象持有短生命周期对象的引用）以及优化" class="headerlink" title="8、内存泄露的原因（长生命周期对象持有短生命周期对象的引用）以及优化"></a>8、内存泄露的原因（长生命周期对象持有短生命周期对象的引用）以及优化</h3>]]></content>
      <categories>
        <category>工作随笔</category>
      </categories>
      <tags>
        <tag>工作随笔</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>老婆我爱你</title>
    <url>/2018/01/12/%E8%80%81%E5%A9%86%E6%88%91%E7%88%B1%E4%BD%A0/</url>
    <content><![CDATA[<p>程序员式的表白！<br><img src="/images/love.jpg" alt><br><a id="more"></a><br>这是我的第一遍博客！</p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
        <tag>家庭</tag>
      </tags>
  </entry>
</search>
