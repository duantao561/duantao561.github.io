---
title: 算法(1)--不使用加号实现 A+B go语言实现
date: 2019-08-23 15:03:03
tags:
  - 算法
categories: 
  - 算法
---

Go 不使用加号实现 A+B，此问题来自： [lintcode](https://www.lintcode.com/problem/a-b-problem/description)

## 问题描述：

说明
a和b都是 32位 整数么？

是的
我可以使用位运算符么？

当然可以
样例
如果 a=1 并且 b=2，返回3。

挑战
显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）
<!-- more -->
## 代码实现
Go代码如下：

```go
package main

import "fmt"

func main() {
	i := aplusb(5, 17)
	fmt.Println(i)
}

func aplusb(a int, b int) int {
	if a == 0 {
		return b
	}
	if b == 0 {
		return a
	}

	x1 := a ^ b
	x2 := (a & b) << 1

	return aplusb(x1, x2)
}

```
C代码如下：

```c
int Add(int a,int b)
{
 int jw=a&b;
 int jg=a^b;
 while(jw)
 {
  int t_a=jg;
  int t_b=jw<<1;
  jw=t_a&t_b;
  jg=t_a^t_b;
 }
 return jg;
}
```

##分析
用位运算实现加法也就是计算机用二进制进行运算，32位的CPU只能表示32位内的数，这里先用1位数的加法来进行，在不考虑进位的基础上，如下

```
1 + 1 = 0
1 + 0 = 1
0 + 1 = 1
0 + 0 = 0
```

很明显这几个表达式可以用位运算的“^”来代替（不考虑进位的情况下位运算符中的异或^可以表示+号），如下

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
```
这样我们就完成了简单的一位数加法，那么要进行二位的加法，这个方法可行不可行呢？肯定是不行的，矛盾就在于，如何去
获取进位？要获取进位我们可以如下思考：

```
0 + 0 = 0
1 + 0 = 0
0 + 1 = 0
1 + 1 = 1
//换个角度看就是这样
0 & 0 = 不进位
1 & 0 = 不进位
0 & 1 = 不进位
1 & 1 = 进位
```
正好，在位运算中，我们用“<<”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式

//进位可以用如下表示：（位运算符中的与运算符&和左移运算符<<可以模拟加法中的进位）
`(x&y)<<1`

```
到这里，我们基本上拥有了这样两个表达式

x^y //执行加法
(x&y)<<1 //进位操作
我们来做个2位数的加法，在不考虑进位的情况下

11+01 = 100  // 本来的算法
 
// 用推算的表达式计算
11 ^ 01 = 10
 
(11 & 01) << 1 = 10
 
//到这里 我们用普通的加法去运算这两个数的时候就可以得到 10 + 10 = 100
//但是我们不需要加法，所以要想别的方法，如果让两个数再按刚才的算法计算一次呢
10 ^ 10 = 00
 
(10 & 10) << 1 = 100
到这里基本上就得出结论了，其实后面的那个 “00” 已经不用再去计算了，因为第一个表达式就已经算出了结果。

继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果。
```

##现总结如下:
1. *定理1*：设a，b为两个二进制数，则a+b = a^b + (a&b)<<1。  
	*证明*：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&b)<<1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。
2. *定理2*：使用定理1可以实现只用位运算进行加法运算。  
	*证明*：利用定理1中的等式不停对自身进行迭代。每迭代一次，进位补偿右边就多一位0，因此最多需要加数二进制位长度次迭代，进位补偿就变为0，这时运算结束。